<#
    MIT License

    Copyright (c) Microsoft Corporation.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE
#>

# Version 23.03.22.1926

#Requires -Version 3.0

<#
.SYNOPSIS
    This script audits mails, calendar and task items and check if PidLidReminderFileParameter property is populated or not.
    If required admins can use this script to cleanup the property for items they find malicious or even delete these items permanently.
.DESCRIPTION
    There are two modes in which we can run the script Audit and Cleanup.

    Audit Mode: Script provides a csv to the admins with details of items that have PidLidReminderFileParameter property populated.
    Cleanup Mode: Script performs Cleanup action on items by either clearing the property or deleting the mail itself.

    Prerequisites to run the script for Exchange Server on-premises: You need to have ApplicationImpersonation role.
    You can create a new role group with the required permissions by running the following PowerShell command in an elevated Exchange Management Shell (EMS):
    `New-RoleGroup -Name "CVE-2023-23397-Script" -Roles "ApplicationImpersonation" -Description "Permission to run the CVE-2023-23397 script"`

    Prerequisites to run the script for Exchange Online: You need to be a member of Organization Management.
    The script will create an application with full access permission on all the mailboxes.

    The script uses EWS managed api to make ews calls in order to fetch items from user mailboxes.
    So the machine on which the script is run should be able to make EWS calls to Exchange Server.
.PARAMETER CreateAzureApplication
    Use this switch to create a Azure AD application that can be used for running the script in online mode
.PARAMETER DeleteAzureApplication
    Use this switch to delete the Azure AD application
.PARAMETER UserMailboxes
    Use this parameter to provide list of user primary SMTP address.
.PARAMETER StartTimeFilter
    Use this parameter to provide start time filter
.PARAMETER EndTimeFilter
    Use this parameter to provide end time filter
.PARAMETER CleanupAction
    Use this parameter to provide type of cleanup action you want to provide (ClearProperty/ClearItem)
.PARAMETER CleanupInfoFilePath
    Use this parameter to provide path to the csv file containing the details of items to be cleaned up
.PARAMETER EWSExchange2013
    Use this switch if you are running on Exchange 2013 server mailboxes
.PARAMETER MaxCSVLength
    This optional parameter allows you to provide maximum csv length
.PARAMETER AzureEnvironmentName
    This optional parameter allows you to provide Azure environment
.PARAMETER AzureApplicationName
    This optional parameter allows you to provide Azure application name
.PARAMETER EWSOnlineURL
    This optional parameter allows you to provide EWS online url
.PARAMETER EWSOnlineScope
    This optional parameter allows you to provide EWS online scope
.PARAMETER AzureADEndpoint
    This optional parameter allows you to provide Azure AD endpoint
.PARAMETER EWSServerURL
    This optional parameter allows you to provide EWS server URL
.PARAMETER DLLPath
    This optional parameter allows you to provide the path to Microsoft.Exchange.WebServices.dll
.PARAMETER ScriptUpdateOnly
    This optional parameter allows you to only update the script without performing any other actions.
.PARAMETER SkipVersionCheck
    This optional parameter allows you to skip the automatic version check and script update.
.PARAMETER IgnoreCertificateMismatch
    This optional parameter lets you ignore TLS certificate mismatch errors.
.PARAMETER Credential
    This optional parameter lets you pass administrator credential object while running on Exchange Server on-premises.
.PARAMETER UseSearchFolders
    This switch causes the script to use deep-traversal search folders, significantly improving performance.
.PARAMETER SearchFolderCleanup
    Clean up any search folders left behind by the -UseSearchFolders switch.
.PARAMETER TimeoutSeconds
    This optional parameter lets you specify the timeout value for the ExchangeService object. Defaults to 5 minutes.
.EXAMPLE
    PS C:\> .\CVE-2023-23397.ps1 -CreateAzureApplication
    This will run the tool to create a new Azure application with required permissions
.EXAMPLE
    PS C:\> (Get-Mailbox).PrimarySMTPAddress | .\CVE-2023-23397.ps1 -Environment <Online/Onprem>
    This will run the tool in audit mode on all the users present
.EXAMPLE
    PS C:\> .\CVE-2023-23397.ps1 -Environment <Online/Onprem> -CleanupAction ClearItem -CleanupInfoFilePath <path to csv file>
    This will run the tool in clean up mode and clear all the items mentioned in the csv file
#>
[CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'High')]

param(
    [ValidateSet("Online", "Onprem")]
    [Parameter(Mandatory = $true, ParameterSetName = "Audit")]
    [Parameter(Mandatory = $true, ParameterSetName = "Cleanup")]
    [String]$Environment,

    [Parameter(Mandatory = $true, ParameterSetName = "CreateAzureApplication")]
    [Switch]$CreateAzureApplication,

    [Parameter(Mandatory = $true, ParameterSetName = "DeleteAzureApplication")]
    [Switch]$DeleteAzureApplication,

    [Parameter(Mandatory = $true, ParameterSetName = "Audit", ValueFromPipelineByPropertyName = $true)]
    [Alias("PrimarySmtpAddress")]
    [String[]]$UserMailboxes,

    [Parameter(Mandatory = $false, ParameterSetName = "Audit")]
    [DateTime]$StartTimeFilter,

    [Parameter(Mandatory = $false, ParameterSetName = "Audit")]
    [DateTime]$EndTimeFilter,

    [ValidateSet("ClearProperty", "ClearItem")]
    [Parameter(Mandatory = $true, ParameterSetName = "Cleanup")]
    [string]$CleanupAction,

    [ValidateScript({ Test-Path -Path $_ -PathType leaf })]
    [Parameter(Mandatory = $true, ParameterSetName = "Cleanup")]
    [ValidatePattern("(.*?)\.(csv)$")]
    [string]$CleanupInfoFilePath,

    [Parameter(Mandatory = $false, ParameterSetName = "Audit")]
    [Parameter(Mandatory = $false, ParameterSetName = "Cleanup")]
    [switch]$EWSExchange2013,

    [ValidateRange(1, [Int]::MaxValue)]
    [Parameter(Mandatory = $false, ParameterSetName = "Audit")]
    [Int]$MaxCSVLength = 200000,

    [Parameter(Mandatory = $false, ParameterSetName = "CreateAzureApplication")]
    [Parameter(Mandatory = $false, ParameterSetName = "DeleteAzureApplication")]
    [Parameter(Mandatory = $false, ParameterSetName = "Audit")]
    [Parameter(Mandatory = $false, ParameterSetName = "Cleanup")]
    [String]$AzureEnvironmentName = "AzureCloud",

    [Parameter(Mandatory = $false, ParameterSetName = "CreateAzureApplication")]
    [Parameter(Mandatory = $false, ParameterSetName = "DeleteAzureApplication")]
    [Parameter(Mandatory = $false, ParameterSetName = "Audit")]
    [Parameter(Mandatory = $false, ParameterSetName = "Cleanup")]
    [String]$AzureApplicationName = "CVE-2023-23397Application",

    [Parameter(Mandatory = $false, ParameterSetName = "Audit")]
    [Parameter(Mandatory = $false, ParameterSetName = "Cleanup")]
    [Uri]$EWSOnlineURL = "https://outlook.office365.com/EWS/Exchange.asmx",

    [Parameter(Mandatory = $false, ParameterSetName = "Audit")]
    [Parameter(Mandatory = $false, ParameterSetName = "Cleanup")]
    [String]$EWSOnlineScope = "https://outlook.office365.com/.default",

    [Parameter(Mandatory = $false, ParameterSetName = "Audit")]
    [Parameter(Mandatory = $false, ParameterSetName = "Cleanup")]
    [Uri]$AzureADEndpoint = "https://login.microsoftonline.com/",

    [Parameter(Mandatory = $false, ParameterSetName = "Audit")]
    [Parameter(Mandatory = $false, ParameterSetName = "Cleanup")]
    [Uri]$EWSServerURL,

    [ValidateScript({ Test-Path $_ })]
    [Parameter(Mandatory = $false, ParameterSetName = "Audit")]
    [Parameter(Mandatory = $false, ParameterSetName = "Cleanup")]
    [String]$DLLPath,

    [Parameter(Mandatory = $true, ParameterSetName = "ScriptUpdateOnly")]
    [switch]$ScriptUpdateOnly,

    [Parameter(Mandatory = $false, ParameterSetName = "CreateAzureApplication")]
    [Parameter(Mandatory = $false, ParameterSetName = "DeleteAzureApplication")]
    [Parameter(Mandatory = $false, ParameterSetName = "Audit")]
    [Parameter(Mandatory = $false, ParameterSetName = "Cleanup")]
    [switch]$SkipVersionCheck,

    [Parameter(Mandatory = $false, ParameterSetName = "CreateAzureApplication")]
    [Parameter(Mandatory = $false, ParameterSetName = "DeleteAzureApplication")]
    [Parameter(Mandatory = $false, ParameterSetName = "Audit")]
    [Parameter(Mandatory = $false, ParameterSetName = "Cleanup")]
    [switch]$IgnoreCertificateMismatch,

    [Parameter(Mandatory = $false, ParameterSetName = "Audit")]
    [switch]$UseSearchFolders,

    [Parameter(Mandatory = $false, ParameterSetName = "Audit")]
    [switch]$SearchFolderCleanup,

    [Parameter(Mandatory = $false, ParameterSetName = "Audit")]
    [Parameter(Mandatory = $false, ParameterSetName = "Cleanup")]
    [ValidateRange(1, 2147483)]
    [int]$TimeoutSeconds = 300
)

dynamicparam {
    if ($Environment -eq "Onprem") {
        $auditParameterAttribute = [System.Management.Automation.ParameterAttribute]@{
            ParameterSetName = "Audit"
            Mandatory        = $true
        }

        $cleanupParameterAttribute = [System.Management.Automation.ParameterAttribute]@{
            ParameterSetName = "Cleanup"
            Mandatory        = $true
        }
    } else {
        $auditParameterAttribute = [System.Management.Automation.ParameterAttribute]@{
            ParameterSetName = "Audit"
            Mandatory        = $false
        }

        $cleanupParameterAttribute = [System.Management.Automation.ParameterAttribute]@{
            ParameterSetName = "Cleanup"
            Mandatory        = $false
        }
    }

    $attributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
    $attributeCollection.Add($auditParameterAttribute)
    $attributeCollection.Add($cleanupParameterAttribute)

    $credentialType = [System.Management.Automation.PSCredential]
    $dynParameter = New-Object System.Management.Automation.RuntimeDefinedParameter 'Credential', $credentialType, $attributeCollection

    $paramDictionary = New-Object System.Management.Automation.RuntimeDefinedParameterDictionary
    $paramDictionary.Add('Credential', $dynParameter)
    return $paramDictionary
}

begin {
    $BuildVersion = "23.03.22.1926"
    $searchFolderName = "ReminderFileParameterItems"
    $credential = $PSBoundParameters['Credential']


function Write-VerboseLog ($Message) {
    $Script:Logger = $Script:Logger | Write-LoggerInstance $Message
}

function Write-HostLog ($Message) {
    $Script:Logger = $Script:Logger | Write-LoggerInstance $Message
}

function Enable-TrustAnyCertificateCallback {
    param()

    <#
        This helper function can be used to ignore certificate errors. It works by setting the ServerCertificateValidationCallback
        to a callback that always returns true. This is useful when you are using self-signed certificates or certificates that are
        not trusted by the system.
    #>

    Add-Type -TypeDefinition @"
    namespace Microsoft.CSSExchange {
        public class CertificateValidator {
            public static bool TrustAnyCertificateCallback(
                object sender,
                System.Security.Cryptography.X509Certificates.X509Certificate cert,
                System.Security.Cryptography.X509Certificates.X509Chain chain,
                System.Net.Security.SslPolicyErrors sslPolicyErrors) {
                return true;
            }

            public static void IgnoreCertificateErrors() {
                System.Net.ServicePointManager.ServerCertificateValidationCallback = TrustAnyCertificateCallback;
            }
        }
    }
"@
    [Microsoft.CSSExchange.CertificateValidator]::IgnoreCertificateErrors()
}

function Write-Host {
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidOverwritingBuiltInCmdlets', '', Justification = 'Proper handling of write host with colors')]
    [CmdletBinding()]
    param(
        [Parameter(Position = 1, ValueFromPipeline)]
        [object]$Object,
        [switch]$NoNewLine,
        [string]$ForegroundColor
    )
    process {
        $consoleHost = $host.Name -eq "ConsoleHost"

        if ($null -ne $Script:WriteHostManipulateObjectAction) {
            $Object = & $Script:WriteHostManipulateObjectAction $Object
        }

        $params = @{
            Object    = $Object
            NoNewLine = $NoNewLine
        }

        if ([string]::IsNullOrEmpty($ForegroundColor)) {
            if ($null -ne $host.UI.RawUI.ForegroundColor -and
                $consoleHost) {
                $params.Add("ForegroundColor", $host.UI.RawUI.ForegroundColor)
            }
        } elseif ($ForegroundColor -eq "Yellow" -and
            $consoleHost -and
            $null -ne $host.PrivateData.WarningForegroundColor) {
            $params.Add("ForegroundColor", $host.PrivateData.WarningForegroundColor)
        } elseif ($ForegroundColor -eq "Red" -and
            $consoleHost -and
            $null -ne $host.PrivateData.ErrorForegroundColor) {
            $params.Add("ForegroundColor", $host.PrivateData.ErrorForegroundColor)
        } else {
            $params.Add("ForegroundColor", $ForegroundColor)
        }

        Microsoft.PowerShell.Utility\Write-Host @params

        if ($null -ne $Script:WriteHostDebugAction -and
            $null -ne $Object) {
            &$Script:WriteHostDebugAction $Object
        }
    }
}

function SetProperForegroundColor {
    $Script:OriginalConsoleForegroundColor = $host.UI.RawUI.ForegroundColor

    if ($Host.UI.RawUI.ForegroundColor -eq $Host.PrivateData.WarningForegroundColor) {
        Write-Verbose "Foreground Color matches warning's color"

        if ($Host.UI.RawUI.ForegroundColor -ne "Gray") {
            $Host.UI.RawUI.ForegroundColor = "Gray"
        }
    }

    if ($Host.UI.RawUI.ForegroundColor -eq $Host.PrivateData.ErrorForegroundColor) {
        Write-Verbose "Foreground Color matches error's color"

        if ($Host.UI.RawUI.ForegroundColor -ne "Gray") {
            $Host.UI.RawUI.ForegroundColor = "Gray"
        }
    }
}

function RevertProperForegroundColor {
    $Host.UI.RawUI.ForegroundColor = $Script:OriginalConsoleForegroundColor
}

function SetWriteHostAction ($DebugAction) {
    $Script:WriteHostDebugAction = $DebugAction
}

function SetWriteHostManipulateObjectAction ($ManipulateObject) {
    $Script:WriteHostManipulateObjectAction = $ManipulateObject
}

function Write-Verbose {
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidOverwritingBuiltInCmdlets', '', Justification = 'In order to log Write-Verbose from Shared functions')]
    [CmdletBinding()]
    param(
        [Parameter(Position = 1, ValueFromPipeline)]
        [string]$Message
    )

    process {

        if ($null -ne $Script:WriteVerboseManipulateMessageAction) {
            $Message = & $Script:WriteVerboseManipulateMessageAction $Message
        }

        Microsoft.PowerShell.Utility\Write-Verbose $Message

        if ($null -ne $Script:WriteVerboseDebugAction) {
            & $Script:WriteVerboseDebugAction $Message
        }

        # $PSSenderInfo is set when in a remote context
        if ($PSSenderInfo -and
            $null -ne $Script:WriteRemoteVerboseDebugAction) {
            & $Script:WriteRemoteVerboseDebugAction $Message
        }
    }
}

function SetWriteVerboseAction ($DebugAction) {
    $Script:WriteVerboseDebugAction = $DebugAction
}

function SetWriteRemoteVerboseAction ($DebugAction) {
    $Script:WriteRemoteVerboseDebugAction = $DebugAction
}

function SetWriteVerboseManipulateMessageAction ($DebugAction) {
    $Script:WriteVerboseManipulateMessageAction = $DebugAction
}

function Write-Warning {
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidOverwritingBuiltInCmdlets', '', Justification = 'In order to log Write-Warning from Shared functions')]
    [CmdletBinding()]
    param(
        [Parameter(Position = 1, ValueFromPipeline)]
        [string]$Message
    )
    process {

        if ($null -ne $Script:WriteWarningManipulateMessageAction) {
            $Message = & $Script:WriteWarningManipulateMessageAction $Message
        }

        Microsoft.PowerShell.Utility\Write-Warning $Message

        # Add WARNING to beginning of the message by default.
        $Message = "WARNING: $Message"

        if ($null -ne $Script:WriteWarningDebugAction) {
            & $Script:WriteWarningDebugAction $Message
        }

        # $PSSenderInfo is set when in a remote context
        if ($PSSenderInfo -and
            $null -ne $Script:WriteRemoteWarningDebugAction) {
            & $Script:WriteRemoteWarningDebugAction $Message
        }
    }
}

function SetWriteWarningAction ($DebugAction) {
    $Script:WriteWarningDebugAction = $DebugAction
}

function SetWriteRemoteWarningAction ($DebugAction) {
    $Script:WriteRemoteWarningDebugAction = $DebugAction
}

function SetWriteWarningManipulateMessageAction ($DebugAction) {
    $Script:WriteWarningManipulateMessageAction = $DebugAction
}




function Confirm-ProxyServer {
    [CmdletBinding()]
    [OutputType([bool])]
    param (
        [Parameter(Mandatory = $true)]
        [string]
        $TargetUri
    )

    try {
        $proxyObject = ([System.Net.WebRequest]::GetSystemWebProxy()).GetProxy($TargetUri)
        if ($TargetUri -ne $proxyObject.OriginalString) {
            return $true
        } else {
            return $false
        }
    } catch {
        return $false
    }
}

function Invoke-WebRequestWithProxyDetection {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [string]
        $Uri,

        [Parameter(Mandatory = $false)]
        [switch]
        $UseBasicParsing,

        [Parameter(Mandatory = $false)]
        [string]
        $OutFile
    )

    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    if (Confirm-ProxyServer -TargetUri $Uri) {
        $webClient = New-Object System.Net.WebClient
        $webClient.Headers.Add("User-Agent", "PowerShell")
        $webClient.Proxy.Credentials = [System.Net.CredentialCache]::DefaultNetworkCredentials
    }

    $params = @{
        Uri     = $Uri
        OutFile = $OutFile
    }

    if ($UseBasicParsing) {
        $params.UseBasicParsing = $true
    }

    Invoke-WebRequest @params
}

<#
    Determines if the script has an update available.
#>
function Get-ScriptUpdateAvailable {
    [CmdletBinding()]
    [OutputType([PSCustomObject])]
    param (
        [Parameter(Mandatory = $false)]
        [string]
        $VersionsUrl = "https://github.com/microsoft/CSS-Exchange/releases/latest/download/ScriptVersions.csv"
    )

    $BuildVersion = "23.03.22.1926"

    $scriptName = $script:MyInvocation.MyCommand.Name
    $scriptPath = [IO.Path]::GetDirectoryName($script:MyInvocation.MyCommand.Path)
    $scriptFullName = (Join-Path $scriptPath $scriptName)

    $result = [PSCustomObject]@{
        ScriptName     = $scriptName
        CurrentVersion = $BuildVersion
        LatestVersion  = ""
        UpdateFound    = $false
        Error          = $null
    }

    if ((Get-AuthenticodeSignature -FilePath $scriptFullName).Status -eq "NotSigned") {
        Write-Warning "This script appears to be an unsigned test build. Skipping version check."
    } else {
        try {
            $versionData = [Text.Encoding]::UTF8.GetString((Invoke-WebRequestWithProxyDetection $VersionsUrl -UseBasicParsing).Content) | ConvertFrom-Csv
            $latestVersion = ($versionData | Where-Object { $_.File -eq $scriptName }).Version
            $result.LatestVersion = $latestVersion
            if ($null -ne $latestVersion -and $latestVersion -ne $BuildVersion) {
                $result.UpdateFound = $true
            }

            Write-Verbose "Current version: $($result.CurrentVersion) Latest version: $($result.LatestVersion) Update found: $($result.UpdateFound)"
        } catch {
            Write-Verbose "Unable to check for updates: $($_.Exception)"
            $result.Error = $_
        }
    }

    return $result
}


function Confirm-Signature {
    [CmdletBinding()]
    [OutputType([bool])]
    param (
        [Parameter(Mandatory = $true)]
        [string]
        $File
    )

    $IsValid = $false
    $MicrosoftSigningRoot2010 = 'CN=Microsoft Root Certificate Authority 2010, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'
    $MicrosoftSigningRoot2011 = 'CN=Microsoft Root Certificate Authority 2011, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'

    try {
        $sig = Get-AuthenticodeSignature -FilePath $File

        if ($sig.Status -ne 'Valid') {
            Write-Warning "Signature is not trusted by machine as Valid, status: $($sig.Status)."
            throw
        }

        $chain = New-Object -TypeName System.Security.Cryptography.X509Certificates.X509Chain
        $chain.ChainPolicy.VerificationFlags = "IgnoreNotTimeValid"

        if (-not $chain.Build($sig.SignerCertificate)) {
            Write-Warning "Signer certificate doesn't chain correctly."
            throw
        }

        if ($chain.ChainElements.Count -le 1) {
            Write-Warning "Certificate Chain shorter than expected."
            throw
        }

        $rootCert = $chain.ChainElements[$chain.ChainElements.Count - 1]

        if ($rootCert.Certificate.Subject -ne $rootCert.Certificate.Issuer) {
            Write-Warning "Top-level certificate in chain is not a root certificate."
            throw
        }

        if ($rootCert.Certificate.Subject -ne $MicrosoftSigningRoot2010 -and $rootCert.Certificate.Subject -ne $MicrosoftSigningRoot2011) {
            Write-Warning "Unexpected root cert. Expected $MicrosoftSigningRoot2010 or $MicrosoftSigningRoot2011, but found $($rootCert.Certificate.Subject)."
            throw
        }

        Write-Host "File signed by $($sig.SignerCertificate.Subject)"

        $IsValid = $true
    } catch {
        $IsValid = $false
    }

    $IsValid
}

<#
.SYNOPSIS
    Overwrites the current running script file with the latest version from the repository.
.NOTES
    This function always overwrites the current file with the latest file, which might be
    the same. Get-ScriptUpdateAvailable should be called first to determine if an update is
    needed.

    In many situations, updates are expected to fail, because the server running the script
    does not have internet access. This function writes out failures as warnings, because we
    expect that Get-ScriptUpdateAvailable was already called and it successfully reached out
    to the internet.
#>
function Invoke-ScriptUpdate {
    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'High')]
    [OutputType([boolean])]
    param ()

    $scriptName = $script:MyInvocation.MyCommand.Name
    $scriptPath = [IO.Path]::GetDirectoryName($script:MyInvocation.MyCommand.Path)
    $scriptFullName = (Join-Path $scriptPath $scriptName)

    $oldName = [IO.Path]::GetFileNameWithoutExtension($scriptName) + ".old"
    $oldFullName = (Join-Path $scriptPath $oldName)
    $tempFullName = (Join-Path $env:TEMP $scriptName)

    if ($PSCmdlet.ShouldProcess("$scriptName", "Update script to latest version")) {
        try {
            Invoke-WebRequestWithProxyDetection "https://github.com/microsoft/CSS-Exchange/releases/latest/download/$scriptName" -OutFile $tempFullName
        } catch {
            Write-Warning "AutoUpdate: Failed to download update: $($_.Exception.Message)"
            return $false
        }

        try {
            if (Confirm-Signature -File $tempFullName) {
                Write-Host "AutoUpdate: Signature validated."
                if (Test-Path $oldFullName) {
                    Remove-Item $oldFullName -Force -Confirm:$false -ErrorAction Stop
                }
                Move-Item $scriptFullName $oldFullName
                Move-Item $tempFullName $scriptFullName
                Remove-Item $oldFullName -Force -Confirm:$false -ErrorAction Stop
                Write-Host "AutoUpdate: Succeeded."
                return $true
            } else {
                Write-Warning "AutoUpdate: Signature could not be verified: $tempFullName."
                Write-Warning "AutoUpdate: Update was not applied."
            }
        } catch {
            Write-Warning "AutoUpdate: Failed to apply update: $($_.Exception.Message)"
        }
    }

    return $false
}

<#
    Determines if the script has an update available. Use the optional
    -AutoUpdate switch to make it update itself. Pass -Confirm:$false
    to update without prompting the user. Pass -Verbose for additional
    diagnostic output.

    Returns $true if an update was downloaded, $false otherwise. The
    result will always be $false if the -AutoUpdate switch is not used.
#>
function Test-ScriptVersion {
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '', Justification = 'Need to pass through ShouldProcess settings to Invoke-ScriptUpdate')]
    [CmdletBinding(SupportsShouldProcess)]
    [OutputType([bool])]
    param (
        [Parameter(Mandatory = $false)]
        [switch]
        $AutoUpdate,
        [Parameter(Mandatory = $false)]
        [string]
        $VersionsUrl = "https://github.com/microsoft/CSS-Exchange/releases/latest/download/ScriptVersions.csv"
    )

    $updateInfo = Get-ScriptUpdateAvailable $VersionsUrl
    if ($updateInfo.UpdateFound) {
        if ($AutoUpdate) {
            return Invoke-ScriptUpdate
        } else {
            Write-Warning "$($updateInfo.ScriptName) $BuildVersion is outdated. Please download the latest, version $($updateInfo.LatestVersion)."
        }
    }

    return $false
}


function Invoke-CatchActionError {
    [CmdletBinding()]
    param(
        [ScriptBlock]$CatchActionFunction
    )

    if ($null -ne $CatchActionFunction) {
        & $CatchActionFunction
    }
}

<#
    This function will download a NuGet package from the NuGet.org repository.

    NuGet service index request is used to get the search Service Url which will be then used to search for NuGet packages.
    We always try to download the latest version of a package.

    NuGet api documentation:
    https://learn.microsoft.com/en-us/nuget/api/service-index
    https://learn.microsoft.com/en-us/nuget/api/search-query-service-resource
#>

function Get-NuGetPackage {
    [CmdletBinding()]
    [OutputType([PSCustomObject])]
    param(
        [Parameter(Mandatory = $true)]
        [string]$PackageId,

        [Parameter(Mandatory = $false)]
        [string]$Author,

        [Parameter(Mandatory = $false)]
        [string]$SaveTo = $PSScriptRoot,

        [Parameter(Mandatory = $false)]
        [ScriptBlock]$CatchActionFunction
    )

    begin {
        Write-Verbose "Calling: $($MyInvocation.MyCommand)"
        $SaveTo = $SaveTo.TrimEnd("\")
        $packageFound = $false
        $downloadSuccessful = $false
    }
    process {
        if ((Test-Path -Path $SaveTo) -eq $false) {
            Write-Verbose "Path: $SaveTo doesn't exist, creating it"

            try {
                New-Item -ItemType Directory -Path $SaveTo -ErrorAction Stop | Out-Null
            } catch {
                Write-Verbose "Unable to create directory: '$($SaveTo)' - Exception: $($Error[0].Exception.Message)"
                Invoke-CatchActionError $CatchActionFunction
                return
            }
        }

        try {
            $nuGetIndexResponse = Invoke-WebRequestWithProxyDetection -Uri "https://api.nuget.org/v3/index.json" -UseBasicParsing -ErrorAction Stop

            if ($nuGetIndexResponse.StatusCode -eq 200) {
                Write-Verbose "NuGet service index request successful"
                $nuGetIndex = $nuGetIndexResponse.Content | ConvertFrom-Json -ErrorAction Stop
            } else {
                Write-Verbose "NuGet service index request failed with status code: $($nuGetIndexResponse.StatusCode)"
                return
            }

            $nuGetSearchService = ($nuGetIndex.resources | Where-Object { $_.'@type' -eq "SearchQueryService" } | Select-Object -First 1).'@id'
            $nuGetSearchResponse = Invoke-WebRequestWithProxyDetection -Uri ("$($nuGetSearchService)?q={0}" -f $PackageId) -UseBasicParsing -ErrorAction Stop

            if ($nuGetSearchResponse.StatusCode -eq 200) {
                Write-Verbose "NuGet search request successful"
                $nuGetSearch = $nuGetSearchResponse.Content | ConvertFrom-Json -ErrorAction Stop
            } else {
                Write-Verbose "NuGet search request failed with status code: $($nuGetSearchResponse.StatusCode)"
                return
            }

            if ($nuGetSearch.totalHits -ge 1) {
                Write-Verbose "We found: $($nuGetSearch.totalHits) packages with the name: $PackageId"
                Write-Verbose "Applying filter for id: $PackageId"
                $nuGetPackage = $nuGetSearch.data | Where-Object { $_.id -eq $PackageId }

                if ($null -ne $Author) {
                    Write-Verbose "Applying filter for author: $Author"
                    $nuGetPackage = $nuGetPackage | Where-Object { $_.authors -eq $Author }
                }

                if (($null -ne $nuGetPackage) -and
                ($nuGetPackage.title.Count -eq 1)) {
                    Write-Verbose "NuGet package found: $($nuGetPackage.id)"
                    $packageFound = $true
                    Write-Verbose "Description: $($nuGetPackage.description)"
                    $nuGetVersionsUrl = $nuGetPackage.versions[-1].'@id'

                    $nuGetVersionsResponse = Invoke-WebRequestWithProxyDetection -Uri $nuGetVersionsUrl -UseBasicParsing -ErrorAction Stop

                    if ($nuGetVersionsResponse.StatusCode -eq 200) {
                        $nuGetDownloadUrl = ($nuGetVersionsResponse.Content | ConvertFrom-Json -ErrorAction Stop).packageContent

                        $nuGetPackageFileName = $nuGetDownloadUrl.Split("/")[-1]
                        $fullPathToDownloadedFile = "$($SaveTo)\$($nuGetPackageFileName)"
                    }
                }

                if ($null -ne $nuGetDownloadUrl) {
                    if (Test-Path -Path $fullPathToDownloadedFile) {
                        Write-Verbose "File: $fullPathToDownloadedFile already exists, deleting it"
                        Remove-Item -Path $fullPathToDownloadedFile -Force -ErrorAction Stop | Out-Null
                    }

                    Write-Verbose "Downloading package from: $nuGetDownloadUrl"
                    Invoke-WebRequestWithProxyDetection -Uri $nuGetDownloadUrl -OutFile $fullPathToDownloadedFile -UseBasicParsing -ErrorAction Stop

                    if (Test-Path -Path $fullPathToDownloadedFile) {
                        Write-Verbose "Download successful"
                        $downloadSuccessful = $true
                    }
                }
            } else {
                Write-Verbose "No package found with id: $PackageId"
            }
        } catch {
            Write-Verbose "Unable to run WebRequest - Exception: $($Error[0].Exception.Message)"
            Invoke-CatchActionError $CatchActionFunction
            return
        }
    }
    end {
        return [PSCustomObject]@{
            PackageFound         = $packageFound
            DownloadSuccessful   = $downloadSuccessful
            NuGetPackageName     = $nuGetPackageFileName
            NuGetPackageFullPath = $fullPathToDownloadedFile
        }
    }
}


<#
    This function can be used to extract a zip or nupkg file to a specified folder.
    By default, the function will extract the archive to the same folder as the script.
#>

function Invoke-ExtractArchive {
    [CmdletBinding()]
    [OutputType([PSCustomObject])]

    param(
        [Parameter(Mandatory = $false)]
        [string]$TargetFolder = $PSScriptRoot,

        [Parameter(Mandatory = $true)]
        [ValidatePattern("(.*?)\.(zip|nupkg)$")]
        [string]$CompressedFilePath,

        [Parameter(Mandatory = $false)]
        [ScriptBlock]$CatchActionFunction
    )

    begin {
        Write-Verbose "Calling: $($MyInvocation.MyCommand)"
        $successfullyUnzipped = $false
    }
    process {
        if ((Test-Path $TargetFolder) -eq $false) {
            try {
                Write-Verbose "Path: $TargetFolder doesn't exist, creating it"
                New-Item -Path $TargetFolder -ItemType Directory -ErrorAction Stop
            } catch {
                Write-Verbose "Unable to create target folder: $TargetFolder"
                Invoke-CatchActionError $CatchActionFunction
                return
            }
        }

        if ((Test-Path $CompressedFilePath) -eq $false) {
            Write-Verbose "Failed to find the archive: $CompressedFilePath"
            Invoke-CatchActionError $CatchActionFunction
            return
        }

        try {
            Add-Type -AssemblyName "System.IO.Compression.Filesystem" -ErrorAction Stop
            Write-Verbose "Loaded .NET Compression Assembly"
        } catch {
            Write-Verbose "Failed to load .NET Compression Assembly"
            Invoke-CatchActionError $CatchActionFunction
            return
        }

        try {
            [System.IO.Compression.ZipFile]::ExtractToDirectory($CompressedFilePath, $TargetFolder)
            $successfullyUnzipped = $true
        } catch {
            Write-Verbose "Something went wrong while extracting the archive"
            Invoke-CatchActionError $CatchActionFunction
            return
        }
    }
    end {
        return [PSCustomObject]@{
            DecompressionSuccessful     = $successfullyUnzipped
            FullPathToDecompressedFiles = $TargetFolder
        }
    }
}

function Get-NewLoggerInstance {
    [CmdletBinding()]
    param(
        [string]$LogDirectory = (Get-Location).Path,

        [ValidateNotNullOrEmpty()]
        [string]$LogName = "Script_Logging",

        [bool]$AppendDateTime = $true,

        [bool]$AppendDateTimeToFileName = $true,

        [int]$MaxFileSizeMB = 10,

        [int]$CheckSizeIntervalMinutes = 10,

        [int]$NumberOfLogsToKeep = 10
    )

    $fileName = if ($AppendDateTimeToFileName) { "{0}_{1}.txt" -f $LogName, ((Get-Date).ToString('yyyyMMddHHmmss')) } else { "$LogName.txt" }
    $fullFilePath = [System.IO.Path]::Combine($LogDirectory, $fileName)

    if (-not (Test-Path $LogDirectory)) {
        try {
            New-Item -ItemType Directory -Path $LogDirectory -ErrorAction Stop | Out-Null
        } catch {
            throw "Failed to create Log Directory: $LogDirectory"
        }
    }

    return [PSCustomObject]@{
        FullPath                 = $fullFilePath
        AppendDateTime           = $AppendDateTime
        MaxFileSizeMB            = $MaxFileSizeMB
        CheckSizeIntervalMinutes = $CheckSizeIntervalMinutes
        NumberOfLogsToKeep       = $NumberOfLogsToKeep
        BaseInstanceFileName     = $fileName.Replace(".txt", "")
        Instance                 = 1
        NextFileCheckTime        = ((Get-Date).AddMinutes($CheckSizeIntervalMinutes))
        PreventLogCleanup        = $false
        LoggerDisabled           = $false
    } | Write-LoggerInstance -Object "Starting Logger Instance $(Get-Date)"
}

function Write-LoggerInstance {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [object]$LoggerInstance,

        [Parameter(Mandatory = $true, Position = 1)]
        [object]$Object
    )
    process {
        if ($LoggerInstance.LoggerDisabled) { return }

        if ($LoggerInstance.AppendDateTime -and
            $Object.GetType().Name -eq "string") {
            $Object = "[$([System.DateTime]::Now)] : $Object"
        }

        # Doing WhatIf:$false to support -WhatIf in main scripts but still log the information
        $Object | Out-File $LoggerInstance.FullPath -Append -WhatIf:$false

        #Upkeep of the logger information
        if ($LoggerInstance.NextFileCheckTime -gt [System.DateTime]::Now) {
            return
        }

        #Set next update time to avoid issues so we can log things
        $LoggerInstance.NextFileCheckTime = ([System.DateTime]::Now).AddMinutes($LoggerInstance.CheckSizeIntervalMinutes)
        $item = Get-ChildItem $LoggerInstance.FullPath

        if (($item.Length / 1MB) -gt $LoggerInstance.MaxFileSizeMB) {
            $LoggerInstance | Write-LoggerInstance -Object "Max file size reached rolling over" | Out-Null
            $directory = [System.IO.Path]::GetDirectoryName($LoggerInstance.FullPath)
            $fileName = "$($LoggerInstance.BaseInstanceFileName)-$($LoggerInstance.Instance).txt"
            $LoggerInstance.Instance++
            $LoggerInstance.FullPath = [System.IO.Path]::Combine($directory, $fileName)

            $items = Get-ChildItem -Path ([System.IO.Path]::GetDirectoryName($LoggerInstance.FullPath)) -Filter "*$($LoggerInstance.BaseInstanceFileName)*"

            if ($items.Count -gt $LoggerInstance.NumberOfLogsToKeep) {
                $item = $items | Sort-Object LastWriteTime | Select-Object -First 1
                $LoggerInstance | Write-LoggerInstance "Removing Log File $($item.FullName)" | Out-Null
                $item | Remove-Item -Force
            }
        }
    }
    end {
        return $LoggerInstance
    }
}

function Invoke-LoggerInstanceCleanup {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [object]$LoggerInstance
    )
    process {
        if ($LoggerInstance.LoggerDisabled -or
            $LoggerInstance.PreventLogCleanup) {
            return
        }

        Get-ChildItem -Path ([System.IO.Path]::GetDirectoryName($LoggerInstance.FullPath)) -Filter "*$($LoggerInstance.BaseInstanceFileName)*" |
            Remove-Item -Force
    }
}

function Show-Disclaimer {
    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    param(
        [ValidateNotNullOrEmpty()]
        [string]$Message,
        [ValidateNotNullOrEmpty()]
        [string]$Target,
        [ValidateNotNullOrEmpty()]
        [string]$Operation
    )

    if ($PSCmdlet.ShouldProcess($Message, $Target, $Operation) -or
        $WhatIfPreference) {
        return
    } else {
        exit
    }
}

    $loggerParams = @{
        LogName                  = "CVE-2023-23397-$((Get-Date).ToString("yyyyMMddhhmmss"))-Debug"
        AppendDateTimeToFileName = $false
        ErrorAction              = "SilentlyContinue"
    }

    $Script:Logger = Get-NewLoggerInstance @loggerParams

    SetWriteHostAction ${Function:Write-HostLog}
    SetWriteVerboseAction ${Function:Write-VerboseLog}
    SetWriteWarningAction ${Function:Write-HostLog}

    $mode = $PsCmdlet.ParameterSetName

    ## function to create ews managed api service object
    function EWSAuth {
        param(
            [string]$Environment,
            $token,
            $EWSOnlineURL,
            $EWSServerURL
        )
        ## Create the Exchange Service object with credentials
        if ($EWSExchange2013) {
            $Service = New-Object Microsoft.Exchange.WebServices.Data.ExchangeService([Microsoft.Exchange.WebServices.Data.ExchangeVersion]::Exchange2013)
        } else {
            $Service = New-Object Microsoft.Exchange.WebServices.Data.ExchangeService([Microsoft.Exchange.WebServices.Data.ExchangeVersion]::Exchange2016)
        }

        $Service.Timeout = $TimeoutSeconds * 1000

        if ($Environment -eq "Onprem") {
            $Service.Credentials = New-Object Microsoft.Exchange.WebServices.Data.WebCredentials($credential.UserName, [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)))
        } else {
            $Service.Credentials = New-Object Microsoft.Exchange.WebServices.Data.OAuthCredentials($token.access_token)
        }

        if ($Environment -eq "Onprem") {
            if (-not([System.String]::IsNullOrEmpty($EWSServerURL))) {
                $Service.Url = New-Object Uri($EWSServerURL)
                CheckOnpremCredentials -ewsService $Service
            } else {
                try {
                    $Service.AutodiscoverUrl($Credential.UserName)
                } catch [Microsoft.Exchange.WebServices.Data.AutodiscoverLocalException] {
                    Write-Host "Username: $($Credential.UserName) was passed in UPN format but must use a domain which is an accepted domain by Exchange Server." -ForegroundColor Red
                    Write-Host "You must use the -EWSServerURL parameter if the UPN does not match an email domain used by Exchange." -ForegroundColor Red
                    Write-Host "More information: https://aka.ms/CVE-2023-23397ScriptDoc" -ForegroundColor Red
                    Write-Host "Inner Exception`n`n$_" -ForegroundColor Red
                    exit
                } catch [System.FormatException] {
                    Write-Host "Username: $($Credential.UserName) was passed in Domain\SamAccountName format" -ForegroundColor Red
                    Write-Host "You must use the -EWSServerURL parameter if the username is provided in domain\user format." -ForegroundColor Red
                    Write-Host "More information: https://aka.ms/CVE-2023-23397ScriptDoc" -ForegroundColor Red
                    Write-Host "Inner Exception`n`n$_" -ForegroundColor Red
                    exit
                } catch {
                    Write-Host "Unable to make Autodiscover call to fetch EWS endpoint details. Please make sure you have enter valid credentials. Inner Exception`n`n$_" -ForegroundColor Red
                    exit
                }
            }
        } else {
            $Service.Url = $EWSOnlineURL
        }

        return $Service
    }

    ## function to validate onprem credential
    function CheckOnpremCredentials {
        param (
            $ewsService
        )

        try {
            $null = [Microsoft.Exchange.WebServices.Data.Folder]::Bind($ewsService, [Microsoft.Exchange.WebServices.Data.WellKnownFolderName]::MsgFolderRoot)
        } catch [Microsoft.Exchange.WebServices.Data.ServiceRequestException] {
            Write-Host "Unable to connect to EWS endpoint. Please make sure you have enter valid credentials. Inner Exception`n`n$_" -ForegroundColor Red
            exit
        } catch [Microsoft.Exchange.WebServices.Data.ServiceResponseException] {
            if ($_.Exception.ErrorCode -eq "ErrorNonExistentMailbox") {
                # This is fine. This means this account is not mail-enabled, but credentials worked.
                return
            } elseif ($_.Exception.ErrorCode -eq "ErrorMissingEmailAddress") {
                # On Exchange 2013, even if we handle this error, it doesn't work.
                Write-Host "Could not open mailbox due to ErrorMissingEmailAddress. If running on Exchange 2013, the impersonation user must have a mailbox on prem. Inner Exception`n`n$_" -ForegroundColor Red
                exit
            } else {
                Write-Host "Could not open mailbox. Inner Exception`n`n$_" -ForegroundColor Red
                exit
            }
        } catch {
            Write-Host "Could not open mailbox. Inner Exception`n`n$_" -ForegroundColor Red
            exit
        }
    }

    ## function to add a row to the csv
    function CreateCustomCSV {
        param (
            $mailbox,
            $data,
            [string]$CsvPath
        )

        $ItemType = $data.ItemClass

        if ($data.ItemClass.StartsWith("IPM.Note")) {
            $ItemType = "E-Mail"
        } elseif ($data.ItemClass.StartsWith("IPM.Appointment")) {
            $ItemType = "Calendar"
        } elseif ($data.ItemClass.StartsWith("IPM.Task")) {
            $ItemType = "Task"
        }

        <#
            Make sure to update the $headerLine.Count check if you add more columns or remove some.
            We do the check after running Import-Csv call before processing a csv file that was passed via
            CleanupInfoFilePath parameter.
        #>
        $row = [PSCustomObject]@{
            "Mailbox"                     = $mailbox
            "Id"                          = $data.Id
            "ItemType"                    = $ItemType
            "Sender"                      = ($data.From | Select-Object -ExpandProperty Address) -join ","
            "Recipient"                   = ($data.ToRecipients | Select-Object -ExpandProperty Address) -join ","
            "Subject"                     = $data.Subject
            "DateReceived"                = $data.DateTimeReceived
            "PidLidReminderFileParameter" = $data.ExtendedProperties[0].Value
            "Cleanup"                     = "N"
        }

        $row | Export-Csv -Path $CsvPath -Delimiter "," -NoTypeInformation -Append -Encoding utf8 -Force
    }

    # Define a function to get all the SubFolders of a given folder
    function GetSubFolders {
        param (
            $folder,
            $foldersList
        )
        # Get the SubFolders of the folder
        $folderView = New-Object Microsoft.Exchange.WebServices.Data.FolderView(100)
        do {
            $folder.FindFolders($folderView) | ForEach-Object {
                # Add the folder path to the list
                $null = $foldersList.Add($_)
                # Recursively get the SubFolders of this folder
                GetSubFolders -folder $_ -foldersList $foldersList
            }
            $folderView.Offset += $result.Folders.Count
        } while ($result.MoreAvailable -eq $true)
    }

    ## function to find item on basis of store ID
    function FindItem {
        param (
            [Microsoft.Exchange.WebServices.Data.ExchangeService]$exchangeService,
            [string]$Id
        )
        $ps = New-Object Microsoft.Exchange.WebServices.Data.PropertySet(New-Object Microsoft.Exchange.WebServices.Data.ExtendedPropertyDefinition([Microsoft.Exchange.WebServices.Data.DefaultExtendedPropertySet]::Common, 0x0000851F, [Microsoft.Exchange.WebServices.Data.MapiPropertyType]::String))
        return [Microsoft.Exchange.WebServices.Data.Item]::Bind($exchangeService, $Id, $ps);
    }

    ## function to create OAuth token
    function CreateOAUTHToken {
        param (
            [string]$TenantID,
            [string]$ClientID,
            [string]$AppSecret,
            [string]$AzureADEndpoint,
            [string]$Scope
        )

        try {
            $body = @{
                scope         = $Scope
                client_id     = $ClientID
                client_secret = $AppSecret
                grant_type    = "client_credentials"
            }

            $PostSplat = @{
                ContentType = 'application/x-www-form-urlencoded'
                Method      = 'POST'

                # Create string by joining bodyList with '&'
                Body        = $body
                Uri         = "$AzureADEndpoint$TenantID/oauth2/v2.0/token"
            }

            $Token = Invoke-RestMethod @PostSplat
        } catch {
            Write-Host "`nFailure creating EWS auth token, exiting Program. Please review the error message below and re-run the program:`n`n$_" -ForegroundColor Red
            exit
        }

        $script:tokenLastRefreshTime = (Get-Date)

        return $Token
    }

    function ConnectAzureAD {
        [CmdletBinding()]
        param(
            [Parameter(Mandatory = $true)]
            [string]$AzureEnvironmentName
        )

        try {
            Import-Module "AzureAD" -ErrorAction Stop
            Write-Host "`nPrompting user for authentication, please minimize this window if you do not see an authorization prompt as it may be in the background"
            Connect-AzureAD -AzureEnvironmentName $AzureEnvironmentName -ErrorAction Stop
        } catch [System.IO.FileNotFoundException] {
            Write-Host "The AzureAD module was not found on this computer. Please install it by running: Install-Module -Name `"AzureAD`"" -ForegroundColor Red
            Write-Host "AzureAD module requires PowerShell version 5.0 or higher. You're running PowerShell $($PSVersionTable.PSVersion)" -ForegroundColor Red
            exit
        } catch {
            Write-Host "Unable to connect to Azure AD. Inner Exception`n`n$_" -ForegroundColor Red
            exit
        }
    }

    ## function that create an App secret to for a given application and return it
    function GetApplicationDetails {
        param (
            $AzureApplicationName,
            $AzureEnvironmentName
        )

        ConnectAzureAD -AzureEnvironmentName $AzureEnvironmentName

        try {
            $aadApplication = Get-AzureADApplication -Filter "DisplayName eq '$AzureApplicationName'"
        } catch {
            Write-Host "No Azure Application found with the name $AzureApplicationName. Please re-run the script with -CreateAzureApplication to create the application. Inner Exception`n`n$_" -ForegroundColor Red
            exit
        }

        if ($null -eq $aadApplication) {
            Write-Host "No Azure Application found with the name $AzureApplicationName. Please re-run the script with -CreateAzureApplication to create the application." -ForegroundColor Red
            exit
        }

        #Assign App Password, make it valid for 7 days
        $appPassword = New-AzureADApplicationPasswordCredential -ObjectId $aadApplication.ObjectId -CustomKeyIdentifier "AppAccessKey" -EndDate (Get-Date).AddDays(7) -ErrorAction Stop

        Write-Host "`nWaiting 60 seconds for app credentials to register.."
        Start-Sleep -Seconds 60
        Write-Host "`nContinuing..."

        return @{
            "TenantID"  = (Get-AzureADTenantDetail).ObjectId
            "ClientID"  = $aadApplication.AppId
            "AppSecret" = $appPassword.Value
        }
    }

    ## function to delete Azure AD application
    function DeleteApplication {
        param (
            $AzureEnvironmentName,
            $AzureApplicationName
        )

        ConnectAzureAD -AzureEnvironmentName $AzureEnvironmentName

        try {
            $app = Get-AzureADApplication -Filter "DisplayName eq '$AzureApplicationName'"

            if ($null -eq $app) {
                Write-Host "No application with name $AzureApplicationName found" -ForegroundColor Red
                exit
            }

            Remove-AzureADApplication -ObjectId $app.ObjectId

            if (Get-AzureADApplication -Filter "DisplayName eq '$AzureApplicationName'") {
                Write-Host "Unable to delete the Azure AD application. Please try again or delete it manually." -ForegroundColor Red
                exit
            }
        } catch {
            Write-Host "Unable to delete the Azure AD application. Please try again or delete it manually. Inner Exception`n`n$_"
            exit
        }

        Write-Host "Successfully deleted the application $AzureApplicationName" -ForegroundColor Green
    }

    ## function to create Azure AD application
    function CreateApplication {
        param(
            $AzureEnvironmentName,
            $AzureApplicationName
        )

        ConnectAzureAD -AzureEnvironmentName $AzureEnvironmentName

        $aadApplication = Get-AzureADApplication -Filter "DisplayName eq '$AzureApplicationName'"

        if ($null -ne $aadApplication) {
            Write-Host "Application with name $AzureApplicationName already exists..."
            Write-Host "Client ID: $($aadApplication.AppId)" -ForegroundColor Green
            exit
        }

        ## Creating application with default name
        [string]$appName = $AzureApplicationName

        try {
            $aadApplication = New-AzureADApplication -DisplayName $appName
        } catch {
            Write-Host "`nThere was an error creating the application, please reference the error below and try again Inner Exception`n`n$_" -ForegroundColor Red
            exit
        }

        #Add current user to owner of newly created application
        $currentUser = (Get-AzureADUser -ObjectId (Get-AzureADCurrentSessionInfo).Account.Id)
        Write-Host "`nAdding user $($currentUser.UserPrincipalName) as owner of $appName"
        Add-AzureADApplicationOwner -ObjectId $aadApplication.ObjectId -RefObjectId $currentUser.ObjectId | Out-Null

        #Get Service Principal of MS Graph Resource API
        $ews_SP = Get-AzureADServicePrincipal -All $true | Where-Object { $_.DisplayName -eq "Office 365 Exchange Online" }

        #Initialize RequiredResourceAccess for Microsoft Graph Resource API
        $requiredAccess = New-Object Microsoft.Open.AzureAD.Model.RequiredResourceAccess
        $requiredAccess.ResourceAppId = $ews_SP.AppId
        $requiredAccess.ResourceAccess = New-Object System.Collections.Generic.List[Microsoft.Open.AzureAD.Model.ResourceAccess]

        #Set Application Permissions
        $ApplicationPermissions = @('full_access_as_app')

        #Add app permissions
        foreach ($permission in $ApplicationPermissions) {
            $reqPermission = $null
            #Get required app permission
            $reqPermission = $ews_SP.AppRoles | Where-Object { $_.Value -eq $permission }
            if ($reqPermission) {
                $resourceAccess = New-Object Microsoft.Open.AzureAD.Model.ResourceAccess
                $resourceAccess.Type = "Role"
                $resourceAccess.Id = $reqPermission.Id
                #Add required app permission
                $requiredAccess.ResourceAccess.Add($resourceAccess)
            } else {
                Write-Host "App permission $permission not found in the Graph Resource API" -ForegroundColor Red
            }
        }

        #Add required resource accesses
        $requiredResourcesAccess = New-Object System.Collections.Generic.List[Microsoft.Open.AzureAD.Model.RequiredResourceAccess]
        $requiredResourcesAccess.Add($requiredAccess)

        #Set permissions in newly created Azure AD App
        $appObjectId = $aadApplication.ObjectId
        Write-Host "`nSetting Azure AD Permissions"
        Set-AzureADApplication -ObjectId $appObjectId -RequiredResourceAccess $requiredResourcesAccess | Out-Null

        #Create Service Principal
        $appId = $aadApplication.AppId
        $servicePrincipal = New-AzureADServicePrincipal -AppId $appId -Tags @("WindowsAzureActiveDirectoryIntegratedApp")

        #Grant Admin Consent for App Permissions
        $requiredResourcesAccess = (Get-AzureADApplication -ObjectId $appObjectId).RequiredResourceAccess

        Write-Host "`nAssigning Necessary Azure AD Service Roles"
        foreach ($resourceAppAccess in $requiredResourcesAccess) {
            $resourceApp = Get-AzureADServicePrincipal -All $true | Where-Object { $_.AppId -eq $resourceAppAccess.ResourceAppId }

            foreach ($permission in $resourceAppAccess.ResourceAccess) {
                if ($permission.Type -eq "Role") {
                    New-AzureADServiceAppRoleAssignment -ObjectId $servicePrincipal.ObjectId -PrincipalId $servicePrincipal.ObjectId -ResourceId $resourceApp.ObjectId -Id $permission.Id | Out-Null
                }
            }
        }

        #Use newly created app to query graphAPI
        [string]$ClientID = $aadApplication.AppId

        Write-Host "Application created with required permissions. Client ID: $ClientID" -ForegroundColor Green
    }

    ## function to check if a given token is expired and renew it
    function CheckTokenExpiry {
        param (
            $applicationInfo,
            [ref]$ewsService,
            [ref]$token,
            [string]$Environment,
            $EWSOnlineURL,
            $EWSOnlineScope,
            $AzureADEndpoint
        )

        if ($Environment -eq "Onprem") {
            return
        }

        # if token is going to expire in next 5 min then refresh it
        if ($null -eq $script:tokenLastRefreshTime -or $script:tokenLastRefreshTime.AddMinutes(55) -lt (Get-Date)) {
            $token.Value = CreateOAUTHToken -TenantID $applicationInfo.TenantID -ClientID $applicationInfo.ClientID -AppSecret $applicationInfo.AppSecret -AzureADEndpoint $AzureADEndpoint -Scope $EWSOnlineScope
            $ewsService.Value = EWSAuth -Environment $Environment -token $token.Value -EWSOnlineURL $EWSOnlineURL
        }
    }

    ## function to get our named search folder
    function GetSearchFolder {
        param($ewsService, $userMailbox)

        $searchFoldersId = New-Object Microsoft.Exchange.WebServices.Data.FolderId([Microsoft.Exchange.WebServices.Data.WellKnownFolderName]::Root, $userMailbox)
        $searchFoldersFolder = [Microsoft.Exchange.WebServices.Data.Folder]::Bind($ewsService, $searchFoldersId)
        $searchFoldersView = New-Object Microsoft.Exchange.WebServices.Data.FolderView(1)
        $searchFoldersFilter = New-Object Microsoft.Exchange.WebServices.Data.SearchFilter+IsEqualTo([Microsoft.Exchange.WebServices.Data.FolderSchema]::DisplayName, $searchFolderName)
        $results = $searchFoldersFolder.FindFolders($searchFoldersFilter, $searchFoldersView)
        return $results
    }

    ## function to create our named search folder
    function NewSearchFolder {
        param($ewsService, $userMailbox)

        $rootFolderId = New-Object Microsoft.Exchange.WebServices.Data.FolderId([Microsoft.Exchange.WebServices.Data.WellKnownFolderName]::MsgFolderRoot, $userMailbox)
        $searchFoldersId = New-Object Microsoft.Exchange.WebServices.Data.FolderId([Microsoft.Exchange.WebServices.Data.WellKnownFolderName]::Root, $userMailbox)

        $mySearchFolder = New-Object Microsoft.Exchange.WebServices.Data.SearchFolder($ewsService)
        $mySearchFolder.DisplayName = $searchFolderName
        $mySearchFolder.SearchParameters.SearchFilter = $searchFilterCollection
        $mySearchFolder.SearchParameters.RootFolderIds.Add($rootFolderId)
        $mySearchFolder.SearchParameters.Traversal = [Microsoft.Exchange.WebServices.Data.SearchFolderTraversal]::Deep
        [void]$mySearchFolder.Save($searchFoldersId)
    }

    function RemoveSearchFolder {
        param($ewsService, $userMailbox)

        $searchFolders = @(GetSearchFolder $ewsService $userMailbox)
        if ($searchFolders.Count -gt 0) {
            Write-Host "  Cleaning up search folder."
            [void]$searchFolders[0].Delete([Microsoft.Exchange.WebServices.Data.DeleteMode]::HardDelete)
        }
    }

    function GetSearchFolderItemResults {
        param($ewsService, $userMailbox)

        $searchFolders = @(GetSearchFolder $ewsService $userMailbox)
        if ($searchFolders.Count -lt 1) {
            Write-Host "Search folder missing. Could not get results."
            return
        }

        $offset = 0
        $pageSize = 100
        $findItemsResults = $null
        do {
            $itemView = New-Object Microsoft.Exchange.WebServices.Data.ItemView($pageSize, $offset);
            $findItemsResults = $searchFolders[0].FindItems($itemView)
            foreach ($item in $findItemsResults.Items) {
                $item
            }

            $offset = $findItemsResults.NextPageOffset
        } while ($findItemsResults.MoreAvailable)
    }

    $mailAddresses = New-Object System.Collections.ArrayList
} process {
    foreach ($address in $UserMailboxes) {
        [void]$mailAddresses.Add($address)
    }
} end {
    Write-Host ("CVE-2023-23397 script version $($BuildVersion)") -ForegroundColor Green

    if (([System.String]::IsNullOrEmpty($CleanupInfoFilePath)) -and
        ($ScriptUpdateOnly -eq $false) -and
        ($UseSearchFolders -eq $false) -and
        ($SearchFolderCleanup -eq $false)) {
        $newSearchFeatureWording = "Did you know?" +
        "`nWe've introduced a new asynchronous search feature (preview) in this version to improve the performance of the search." +
        "`nIt's disabled by default and can be enabled by using the following parameters:" +
        "`n" +
        "`nUseSearchFolders: Enable deep-traversal SearchFolders search to significantly improve performance" +
        "`nSearchFolderCleanup: Clean up any SearchFolders left behind by the -UseSearchFolders switch" +
        "`n" +
        "`nMore information: https://aka.ms/CVE-2023-23397ScriptDocFAQ"
        Write-Host ""
        Write-Host $newSearchFeatureWording -ForegroundColor Cyan
        Write-Host ""
        Start-Sleep -Seconds 3
    }

    if ($ScriptUpdateOnly) {
        switch (Test-ScriptVersion -AutoUpdate -VersionsUrl "https://aka.ms/CVE-2023-23397-VersionsUrl" -Confirm:$false) {
            ($true) { Write-Host ("Script was successfully updated") -ForegroundColor Green }
            ($false) { Write-Host ("No update of the script performed") -ForegroundColor Yellow }
            default { Write-Host ("Unable to perform ScriptUpdateOnly operation") -ForegroundColor Red }
        }
        return
    }

    if ((-not($SkipVersionCheck)) -and
        (Test-ScriptVersion -AutoUpdate -Confirm:$false)) {
        Write-Host ("Script was updated. Please rerun the command") -ForegroundColor Yellow
        return
    }

    if ($IgnoreCertificateMismatch) {
        Write-Verbose ("IgnoreCertificateMismatch was used -policy will be set to: TrustAllCertsPolicy")
        Enable-TrustAnyCertificateCallback
    }

    if ($CreateAzureApplication) {
        $null = CreateApplication -AzureEnvironmentName $AzureEnvironmentName -AzureApplicationName $AzureApplicationName
        exit
    }

    if ($DeleteAzureApplication) {
        $null = DeleteApplication -AzureEnvironmentName $AzureEnvironmentName -AzureApplicationName $AzureApplicationName
        exit
    }

    $path = $DLLPath

    if ([System.String]::IsNullOrEmpty($path)) {
        Write-Host "Trying to find Microsoft.Exchange.WebServices.dll in the script folder"
        $path = (Get-ChildItem -LiteralPath "$PSScriptRoot\EWS" -Recurse -Filter "Microsoft.Exchange.WebServices.dll" -ErrorAction SilentlyContinue |
                Select-Object -First 1).FullName

        if ([System.String]::IsNullOrEmpty($path)) {
            Write-Host "Microsoft.Exchange.WebServices.dll wasn't found - attempting to download it from the internet" -ForegroundColor Yellow
            $nuGetPackage = Get-NuGetPackage -PackageId "Microsoft.Exchange.WebServices" -Author "Microsoft"

            if ($nuGetPackage.DownloadSuccessful) {
                $unzipNuGetPackage = Invoke-ExtractArchive -CompressedFilePath $nuGetPackage.NuGetPackageFullPath -TargetFolder "$PSScriptRoot\EWS"

                if ($unzipNuGetPackage.DecompressionSuccessful) {
                    $path = (Get-ChildItem -Path $unzipNuGetPackage.FullPathToDecompressedFiles -Recurse -Filter "Microsoft.Exchange.WebServices.dll" |
                            Select-Object -First 1).FullName
                } else {
                    Write-Host "Failed to unzip Microsoft.Exchange.WebServices.dll. Please unzip the package manually." -ForegroundColor Red
                    exit
                }
            } else {
                Write-Host "Failed to download Microsoft.Exchange.WebServices.dll from the internet. Please download the package manually and extract the dll. Provide the path to dll using DLLPath parameter." -ForegroundColor Red
                exit
            }
        } else {
            Write-Host "Microsoft.Exchange.WebServices.dll was found in the script folder" -ForegroundColor Green
        }
    }

    try {
        Import-Module -Name $path -ErrorAction Stop
    } catch {
        Write-Host "Failed to import Microsoft.Exchange.WebServices.dll Inner Exception`n`n$_" -ForegroundColor Red
        exit
    }

    $failedMailboxes = New-Object 'System.Collections.Generic.List[string]'
    $invalidEntries = New-Object 'System.Collections.Generic.List[string]'
    $removedEntries = New-Object 'System.Collections.Generic.List[string]'

    #MailInfo
    $mailInfo = @{
        "Id"                          = [Microsoft.Exchange.WebServices.Data.ItemSchema]::Id
        "Sender"                      = [Microsoft.Exchange.WebServices.Data.EmailMessageSchema]::From
        "Recipient"                   = [Microsoft.Exchange.WebServices.Data.EmailMessageSchema]::ToRecipients
        "Subject"                     = [Microsoft.Exchange.WebServices.Data.EmailMessageSchema]::Subject
        "DateReceived"                = [Microsoft.Exchange.WebServices.Data.EmailMessageSchema]::DateTimeReceived
        "PidLidReminderFileParameter" = New-Object Microsoft.Exchange.WebServices.Data.ExtendedPropertyDefinition([Microsoft.Exchange.WebServices.Data.DefaultExtendedPropertySet]::Common, 0x0000851F, [Microsoft.Exchange.WebServices.Data.MapiPropertyType]::String)
        "ItemClass"                   = [Microsoft.Exchange.WebServices.Data.ItemSchema]::ItemClass
    }

    if ($Environment -eq "Online") {
        $application = GetApplicationDetails -AzureApplicationName $AzureApplicationName -AzureEnvironmentName $AzureEnvironmentName

        $applicationInfo = @{
            "TenantID"  = $application.Tenant.Id
            "ClientID"  = $application.ClientID
            "AppSecret" = $application.AppSecret
        }

        #Create OAUTH token
        $EWSToken = CreateOAUTHToken -TenantID $applicationInfo.TenantID -ClientID $applicationInfo.ClientID -AppSecret $applicationInfo.AppSecret -Scope $EWSOnlineScope -AzureADEndpoint $AzureADEndpoint

        $ewsService = EWSAuth -Environment $Environment -Token $EWSToken -EWSOnlineURL $EWSOnlineURL
    } else {
        #Server
        $EWSToken = $null
        $ewsService = EWSAuth -Environment $Environment -EWSServerURL $EWSServerURL
    }

    if ($PSCmdlet.ParameterSetName -eq "Audit") {
        if ($null -eq $mailAddresses -or $mailAddresses.Count -eq 0) {
            Write-Host "No mailbox provided" -ForegroundColor Red
            exit
        }

        $csvFileName = ("AuditResults_$(Get-Date -Format "yyyyMMdd_HHmmss").csv")

        $itemView = New-Object Microsoft.Exchange.WebServices.Data.ItemView([int]::MaxValue)

        $searchFilterCollection = New-Object Microsoft.Exchange.WebServices.Data.SearchFilter+SearchFilterCollection

        if ($null -ne $StartTimeFilter) {
            $searchFilterStartTime = New-Object Microsoft.Exchange.WebServices.Data.SearchFilter+IsGreaterThan([Microsoft.Exchange.WebServices.Data.ItemSchema]::DateTimeCreated, $StartTimeFilter)
            $searchFilterCollection.Add($searchFilterStartTime)
        }

        if ($null -ne $EndTimeFilter) {
            $searchFilterEndTime = New-Object Microsoft.Exchange.WebServices.Data.SearchFilter+IsLessThan([Microsoft.Exchange.WebServices.Data.ItemSchema]::DateTimeCreated, $EndTimeFilter)
            $searchFilterCollection.Add($searchFilterEndTime)
        }

        $searchFilterPidLidReminderFileParameterExists = New-Object Microsoft.Exchange.WebServices.Data.SearchFilter+Exists($mailInfo["PidLidReminderFileParameter"])
        $searchFilterCollection.Add($searchFilterPidLidReminderFileParameterExists)

        $PropertySet = New-Object Microsoft.Exchange.WebServices.Data.PropertySet
        foreach ($key in $mailInfo.Keys) {
            $PropertySet.Add($mailInfo[$key])
        }

        $mailboxProcessed = 0
        $rowCount = 0

        if ($UseSearchFolders) {
            $actionText = "Creating"
            if ($SearchFolderCleanup) {
                $actionText = "Removing"
            }

            $searchFolderCreationTimer = $null

            foreach ($mailAddress in $mailAddresses) {
                $ewsService.HttpHeaders.Clear()
                $ewsService.HttpHeaders.Add("X-AnchorMailbox", $mailAddress)
                Write-Host ("$actionText search folders in $($mailboxProcessed + 1) of $($mailAddresses.Count) mailboxes (currently: $mailAddress)")

                $userMailbox = New-Object Microsoft.Exchange.WebServices.Data.Mailbox($mailAddress)

                if ($null -eq $userMailbox) {
                    Write-Host ("Unable to get mailbox associated with mail address $mailAddress")
                    $failedMailboxes.Add($mailAddress)
                    $mailboxProcessed += 1
                    continue
                }

                try {
                    # Check for token expiry
                    CheckTokenExpiry -Environment $Environment -token ([ref]$EWSToken) -ewsService ([ref]$ewsService) -applicationInfo $applicationInfo -EWSOnlineURL $EWSOnlineURL -EWSOnlineScope $EWSOnlineScope -AzureADEndpoint $AzureADEndpoint
                    $ewsService.ImpersonatedUserId = New-Object Microsoft.Exchange.WebServices.Data.ImpersonatedUserId([Microsoft.Exchange.WebServices.Data.ConnectingIdType]::SmtpAddress, $mailAddress)

                    if ($SearchFolderCleanup) {
                        RemoveSearchFolder $ewsService $userMailbox
                        $mailboxProcessed += 1
                        continue
                    }

                    $searchFolders = GetSearchFolder $ewsService $userMailbox

                    if ($searchFolders.Count -gt 0) {
                        Write-Host "  Search folder already exists in this mailbox."
                        $mailboxProcessed += 1
                        continue
                    }

                    # Create a new search folder
                    if ($null -eq $searchFolderCreationTimer) {
                        $searchFolderCreationTimer = New-Object System.Diagnostics.Stopwatch
                        $searchFolderCreationTimer.Start()
                    }

                    NewSearchFolder $ewsService $userMailbox
                    $mailboxProcessed += 1
                } catch [Microsoft.Exchange.WebServices.Data.ServiceResponseException] {
                    Write-Host ("Unable to access mailbox: $mailAddress") -ForegroundColor Red
                    Write-Host ("Inner Exception: $_") -ForegroundColor Red
                    $failedMailboxes.Add($mailAddress)
                    $mailboxProcessed += 1
                    continue
                } catch {
                    Write-Host ("Unable to process mailbox $mailAddress as it seems to be inaccessible. Inner Exception:`n`n$_") -ForegroundColor Red
                    $failedMailboxes.Add($mailAddress)
                    $mailboxProcessed += 1
                    continue
                }
            }

            if (-not $SearchFolderCleanup) {
                if ($null -ne $SearchFolderCreationTimer) {
                    $waitSecondsAfterCreatingFirstSearchFolder = 60
                    if ($SearchFolderCreationTimer.ElapsedMilliseconds -lt $waitSecondsAfterCreatingFirstSearchFolder * 1000) {
                        $secondsElapsed = $SearchFolderCreationTimer.ElapsedMilliseconds / 1000
                        $secondsRemaining = $waitSecondsAfterCreatingFirstSearchFolder - $secondsElapsed
                        Write-Host "First search folder created $secondsElapsed seconds ago. Waiting $secondsRemaining seconds to allow for population."
                        Start-Sleep -Seconds $secondsRemaining
                    }
                }

                $mailboxProcessed = 0

                foreach ($mailAddress in $mailAddresses) {
                    if ($failedMailboxes.Contains($mailAddress)) {
                        $mailboxProcessed += 1
                        continue
                    }

                    $ewsService.HttpHeaders.Clear()
                    $ewsService.HttpHeaders.Add("X-AnchorMailbox", $mailAddress)
                    Write-Host ("Getting search results in $($mailboxProcessed + 1) of $($mailAddresses.Count) mailboxes (currently: $mailAddress)")

                    $userMailbox = New-Object Microsoft.Exchange.WebServices.Data.Mailbox($mailAddress)

                    $itemResults = @()

                    try {
                        # Check for token expiry
                        CheckTokenExpiry -Environment $Environment -token ([ref]$EWSToken) -ewsService ([ref]$ewsService) -applicationInfo $applicationInfo -EWSOnlineURL $EWSOnlineURL -EWSOnlineScope $EWSOnlineScope -AzureADEndpoint $AzureADEndpoint
                        $ewsService.ImpersonatedUserId = New-Object Microsoft.Exchange.WebServices.Data.ImpersonatedUserId([Microsoft.Exchange.WebServices.Data.ConnectingIdType]::SmtpAddress, $mailAddress)

                        [Microsoft.Exchange.WebServices.Data.Item[]]$itemResults = @(GetSearchFolderItemResults $ewsService $userMailbox)
                    } catch [Microsoft.Exchange.WebServices.Data.ServiceResponseException] {
                        Write-Host ("Unable to access mailbox: $mailAddress") -ForegroundColor Red
                        Write-Host ("Inner Exception: $_") -ForegroundColor Red
                        $failedMailboxes.Add($mailAddress)
                        $mailboxProcessed += 1
                        continue
                    } catch {
                        Write-Host ("Unable to process mailbox $mailAddress as it seems to be inaccessible. Inner Exception:`n`n$_") -ForegroundColor Red
                        $failedMailboxes.Add($mailAddress)
                        $mailboxProcessed += 1
                        continue
                    }

                    $IdsProcessed = New-Object 'System.Collections.Generic.HashSet[string]'

                    if ($itemResults.Count -lt 1) {
                        $mailboxProcessed += 1
                        continue
                    }

                    $items = $ewsService.LoadPropertiesForItems($itemResults, $PropertySet)

                    foreach ($item in $items) {
                        if (-not $IdsProcessed.Contains($item.Item.Id) -and -not [System.String]::IsNullOrEmpty($item.Item.ExtendedProperties[0].Value)) {
                            CreateCustomCSV -mailbox $mailAddress -data $item.Item -CsvPath $csvFileName
                            $rowCount ++
                            if ($rowCount -ge $MaxCSVLength) {
                                Write-Host ("The csv file has reached it's maximum limit of $MaxCSVLength rows... aborting... Please apply appropriate filters to reduce the result size")
                                Write-Host ("Please find the audit results in $csvFileName created in the current folder.")
                                exit
                            }
                            [void]$IdsProcessed.Add($item.Item.Id)
                        }
                    }

                    $mailboxProcessed ++;
                }
            }
        } else {
            foreach ($mailAddress in $mailAddresses) {
                $ewsService.HttpHeaders.Clear()
                $ewsService.HttpHeaders.Add("X-AnchorMailbox", $mailAddress)
                Write-Host ("Scanning $($mailboxProcessed + 1) of $($mailAddresses.Count) mailboxes (currently: $mailAddress)")

                $userMailbox = New-Object Microsoft.Exchange.WebServices.Data.Mailbox($mailAddress)

                if ($null -eq $userMailbox) {
                    Write-Host ("Unable to get mailbox associated with mail address $mailAddress")
                    $failedMailboxes.Add($mailAddress)
                    $mailboxProcessed += 1
                    continue
                }

                try {
                    # Check for token expiry
                    CheckTokenExpiry -Environment $Environment -token ([ref]$EWSToken) -ewsService ([ref]$ewsService) -applicationInfo $applicationInfo -EWSOnlineURL $EWSOnlineURL -EWSOnlineScope $EWSOnlineScope -AzureADEndpoint $AzureADEndpoint
                    $ewsService.ImpersonatedUserId = New-Object Microsoft.Exchange.WebServices.Data.ImpersonatedUserId([Microsoft.Exchange.WebServices.Data.ConnectingIdType]::SmtpAddress, $mailAddress)

                    $rootFolderId = New-Object Microsoft.Exchange.WebServices.Data.FolderId([Microsoft.Exchange.WebServices.Data.WellKnownFolderName]::MsgFolderRoot, $userMailbox)
                    $rootFolder = [Microsoft.Exchange.WebServices.Data.Folder]::Bind($ewsService, $rootFolderId)

                    # Create a new ArrayList to hold the folder
                    $foldersList = New-Object System.Collections.ArrayList

                    GetSubFolders -folder $rootFolder -foldersList $foldersList
                } catch [Microsoft.Exchange.WebServices.Data.ServiceResponseException] {
                    Write-Host ("Unable to access mailbox: $mailAddress") -ForegroundColor Red
                    Write-Host ("Inner Exception: $_") -ForegroundColor Red
                    $failedMailboxes.Add($mailAddress)
                    $mailboxProcessed += 1
                    continue
                } catch {
                    Write-Host ("Unable to process mailbox $mailAddress as it seems to be inaccessible. Inner Exception:`n`n$_") -ForegroundColor Red
                    $failedMailboxes.Add($mailAddress)
                    $mailboxProcessed += 1
                    continue
                }

                $IdsProcessed = New-Object 'System.Collections.Generic.HashSet[string]'

                foreach ($folder in $foldersList) {
                    try {
                        # Check for token expiry
                        CheckTokenExpiry -Environment $Environment -token ([ref]$EWSToken) -ewsService ([ref]$ewsService) -applicationInfo $applicationInfo -EWSOnlineURL $EWSOnlineURL -EWSOnlineScope $EWSOnlineScope -AzureADEndpoint $AzureADEndpoint
                        $ewsService.ImpersonatedUserId = New-Object Microsoft.Exchange.WebServices.Data.ImpersonatedUserId([Microsoft.Exchange.WebServices.Data.ConnectingIdType]::SmtpAddress, $mailAddress)
                        $results = $ewsService.FindItems($folder.Id, $searchFilterCollection, $itemView)
                        if ($null -ne $results -and $null -ne $results.Items -and $results.Items.Count -gt 0) {
                            $items = $ewsService.LoadPropertiesForItems($results.Items, $PropertySet)
                        } else {
                            continue
                        }

                        foreach ($item in $items) {
                            if (-not $IdsProcessed.Contains($item.Item.Id) -and -not [System.String]::IsNullOrEmpty($item.Item.ExtendedProperties[0].Value)) {
                                CreateCustomCSV -mailbox $mailAddress -data $item.Item -CsvPath $csvFileName
                                $rowCount ++
                                if ($rowCount -ge $MaxCSVLength) {
                                    Write-Host ("The csv file has reached it's maximum limit of $MaxCSVLength rows... aborting... Please apply appropriate filters to reduce the result size")
                                    Write-Host ("Please find the audit results in $csvFileName created in the current folder.")
                                    exit
                                }
                                [void]$IdsProcessed.Add($item.Item.Id)
                            }
                        }
                    } catch {
                        Write-Host "Error while scanning $($folder.DisplayName) of the mailbox $mailAddress. Inner Exception:`n`n$_" -ForegroundColor Red
                    }
                }

                $mailboxProcessed ++;
            }
        }

        if (-not $SearchFolderCleanup) {
            if ($rowCount -eq 0) {
                Write-Host "No vulnerable item found" -ForegroundColor Green
            } else {
                Write-Host ("Please find the audit results in $csvFileName created in the current folder.")
            }
        }
    } else {
        $params = @{
            Message   = "Display Warning about Store operation"
            Target    = "The script will perform store operation on mailboxes using EWS"
            Operation = ""
        }

        if ($CleanupAction -eq "ClearProperty") {
            $params.Operation = "Clear the PidLidReminderFileParameter property of mail items"
        }

        if ($CleanupAction -eq "ClearItem") {
            $params.Operation = "Delete items"
        }

        Show-Disclaimer @params

        $importedCsvData = Import-Csv $CleanupInfoFilePath -Delimiter ","
        if ($null -ne $importedCsvData) {
            $headerLine = ($importedCsvData[0] | Get-Member | Where-Object {
                    ($_.MemberType -eq "NoteProperty")
                }).Name

            if ($headerLine.Count -eq 1) {
                # Csv file which isn't in the expected format has only 1 NoteProperty after being imported
                Write-Host "Csv file isn't in the expected format and must be normalized"
                try {
                    # Process line by line and pipe to ConvertFrom-Csv to convert data to PSObject type
                    $cleanupCSV = $importedCsvData | ForEach-Object {
                        ($_.$headerLine)
                    } | ConvertFrom-Csv -Header ((($headerLine).Replace('"', "")).Split(",")) -ErrorAction Stop
                } catch {
                    Write-Host "Something went wrong while normalizing the csv file. Inner Exception:`n`n$_" -ForegroundColor Red
                    exit
                }
            } elseif ($headerLine.Count -eq 9) {
                # Csv file which is in the expected format has 9 NoteProperties after being imported
                Write-Host "Csv file is in the expected format and can be used for cleanup"
                $cleanupCSV = $importedCsvData
            } else {
                # Everything else is unexpected and we stop processing here
                Write-Host "Unable to normalize the csv file please reach out to Microsoft support" -ForegroundColor Red
                exit
            }
        } else {
            Write-Host "Something went wrong while importing the csv file" -ForegroundColor Red
            exit
        }

        $entryCount = 0

        foreach ($entry in $cleanupCSV) {
            $entryCount ++
            if ([System.String]::IsNullOrEmpty($entry.Id)) {
                Write-Host ("No Id present for entry number: $entryCount, Line number: $($entryCount + 1)") -ForegroundColor Red
                $invalidEntries.Add($entryCount)
                continue
            }

            if ([System.String]::IsNullOrEmpty($entry.Mailbox)) {
                Write-Host ("No Mailbox address present for entry number: $entryCount, Line number: $($entryCount + 1)") -ForegroundColor Red
                $invalidEntries.Add($entryCount)
                continue
            }

            if ($null -ne $entry.Cleanup -and $entry.Cleanup.ToLower() -eq "y") {
                # Check for token expiry
                CheckTokenExpiry -Environment $Environment -token ([ref]$EWSToken) -ewsService ([ref]$ewsService) -applicationInfo $applicationInfo -EWSOnlineURL $EWSOnlineURL -EWSOnlineScope $EWSOnlineScope -AzureADEndpoint $AzureADEndpoint
                $ewsService.ImpersonatedUserId = New-Object Microsoft.Exchange.WebServices.Data.ImpersonatedUserId([Microsoft.Exchange.WebServices.Data.ConnectingIdType]::SmtpAddress, $entry.Mailbox)
                $item = FindItem -exchangeService $ewsService -Id $entry.Id
                if ($null -ne $item) {
                    try {
                        if ($CleanupAction -eq "ClearItem") {
                            $item.Delete([Microsoft.Exchange.WebServices.Data.DeleteMode]::HardDelete)
                        } else {
                            if (-not $item.RemoveExtendedProperty($mailInfo["PidLidReminderFileParameter"])) {
                                Write-Host ("Failed to clear property for entry number: $entryCount, Line number: $($entryCount + 1)") -ForegroundColor Red
                                $invalidEntries.Add($entryCount)
                                continue
                            }

                            CheckTokenExpiry -Environment $Environment -token ([ref]$EWSToken) -ewsService ([ref]$ewsService) -applicationInfo $applicationInfo -EWSOnlineURL $EWSOnlineURL -EWSOnlineScope $EWSOnlineScope -AzureADEndpoint $AzureADEndpoint
                            $ewsService.ImpersonatedUserId = New-Object Microsoft.Exchange.WebServices.Data.ImpersonatedUserId([Microsoft.Exchange.WebServices.Data.ConnectingIdType]::SmtpAddress, $entry.Mailbox)

                            if ($entry.ItemType -eq "Calendar") {
                                $item.Update([Microsoft.Exchange.WebServices.Data.ConflictResolutionMode]::AlwaysOverwrite, [Microsoft.Exchange.WebServices.Data.SendInvitationsOrCancellationsMode]::SendToNone)
                            } else {
                                $item.Update([Microsoft.Exchange.WebServices.Data.ConflictResolutionMode]::AlwaysOverwrite)
                            }
                        }
                        # If we get here, it should be successful.
                        $removedEntries.Add($entryCount)
                    } catch {
                        Write-Host ("Unable to perform cleanup action on entry number: $entryCount, Line number: $($entryCount + 1) Inner Exception`n`n$_") -ForegroundColor Red
                        $invalidEntries.Add($entryCount)
                        continue
                    }
                } else {
                    Write-Host ("Unable to find item associated to entry number: $entryCount, Line number: $($entryCount + 1)") -ForegroundColor Red
                    $invalidEntries.Add($entryCount)
                    continue
                }
            }
        }

        Write-Host "Successfully removed $($removedEntries.Count) of $($cleanupCSV.Count)"

        if ($removedEntries.Count -eq 0) {
            Write-Host "No entries were removed. Please update the Cleanup column for the items you wish to cleanup." -ForegroundColor Yellow
        } else {
            Write-Host "Completed cleanup operation!"
        }
    }

    if ($mode -eq "Audit" -and $null -ne $failedMailboxes -and $failedMailboxes.Count -gt 0) {
        Write-Host ("Couldn't Audit mailboxes: {0}" -f [string]::Join(", ", $failedMailboxes))
    }

    if ($mode -eq "Cleanup" -and $null -ne $invalidEntries -and $invalidEntries.Count -gt 0) {
        Write-Host ("Couldn't Cleanup the entries: {0}" -f [string]::Join(", ", $invalidEntries))
    }

    Write-Host ""
    Write-Host ("Do you have feedback regarding the script? Please email ExToolsFeedback@microsoft.com.") -ForegroundColor Green
    Write-Host ""

    Remove-Module -Name "Microsoft.Exchange.WebServices" -ErrorAction SilentlyContinue
}

# SIG # Begin signature block
# MIIn2QYJKoZIhvcNAQcCoIInyjCCJ8YCAQExDzANBglghkgBZQMEAgEFADB5Bgor
# BgEEAYI3AgEEoGswaTA0BgorBgEEAYI3AgEeMCYCAwEAAAQQH8w7YFlLCE63JNLG
# KX7zUQIBAAIBAAIBAAIBAAIBADAxMA0GCWCGSAFlAwQCAQUABCBAVz9m1O8VEex3
# FWT3x3J6pqfWg8Hk0YtCYESiA7I6PKCCDXYwggX0MIID3KADAgECAhMzAAACy7d1
# OfsCcUI2AAAAAALLMA0GCSqGSIb3DQEBCwUAMH4xCzAJBgNVBAYTAlVTMRMwEQYD
# VQQIEwpXYXNoaW5ndG9uMRAwDgYDVQQHEwdSZWRtb25kMR4wHAYDVQQKExVNaWNy
# b3NvZnQgQ29ycG9yYXRpb24xKDAmBgNVBAMTH01pY3Jvc29mdCBDb2RlIFNpZ25p
# bmcgUENBIDIwMTEwHhcNMjIwNTEyMjA0NTU5WhcNMjMwNTExMjA0NTU5WjB0MQsw
# CQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9u
# ZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMR4wHAYDVQQDExVNaWNy
# b3NvZnQgQ29ycG9yYXRpb24wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIB
# AQC3sN0WcdGpGXPZIb5iNfFB0xZ8rnJvYnxD6Uf2BHXglpbTEfoe+mO//oLWkRxA
# wppditsSVOD0oglKbtnh9Wp2DARLcxbGaW4YanOWSB1LyLRpHnnQ5POlh2U5trg4
# 3gQjvlNZlQB3lL+zrPtbNvMA7E0Wkmo+Z6YFnsf7aek+KGzaGboAeFO4uKZjQXY5
# RmMzE70Bwaz7hvA05jDURdRKH0i/1yK96TDuP7JyRFLOvA3UXNWz00R9w7ppMDcN
# lXtrmbPigv3xE9FfpfmJRtiOZQKd73K72Wujmj6/Su3+DBTpOq7NgdntW2lJfX3X
# a6oe4F9Pk9xRhkwHsk7Ju9E/AgMBAAGjggFzMIIBbzAfBgNVHSUEGDAWBgorBgEE
# AYI3TAgBBggrBgEFBQcDAzAdBgNVHQ4EFgQUrg/nt/gj+BBLd1jZWYhok7v5/w4w
# RQYDVR0RBD4wPKQ6MDgxHjAcBgNVBAsTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEW
# MBQGA1UEBRMNMjMwMDEyKzQ3MDUyODAfBgNVHSMEGDAWgBRIbmTlUAXTgqoXNzci
# tW2oynUClTBUBgNVHR8ETTBLMEmgR6BFhkNodHRwOi8vd3d3Lm1pY3Jvc29mdC5j
# b20vcGtpb3BzL2NybC9NaWNDb2RTaWdQQ0EyMDExXzIwMTEtMDctMDguY3JsMGEG
# CCsGAQUFBwEBBFUwUzBRBggrBgEFBQcwAoZFaHR0cDovL3d3dy5taWNyb3NvZnQu
# Y29tL3BraW9wcy9jZXJ0cy9NaWNDb2RTaWdQQ0EyMDExXzIwMTEtMDctMDguY3J0
# MAwGA1UdEwEB/wQCMAAwDQYJKoZIhvcNAQELBQADggIBAJL5t6pVjIRlQ8j4dAFJ
# ZnMke3rRHeQDOPFxswM47HRvgQa2E1jea2aYiMk1WmdqWnYw1bal4IzRlSVf4czf
# zx2vjOIOiaGllW2ByHkfKApngOzJmAQ8F15xSHPRvNMmvpC3PFLvKMf3y5SyPJxh
# 922TTq0q5epJv1SgZDWlUlHL/Ex1nX8kzBRhHvc6D6F5la+oAO4A3o/ZC05OOgm4
# EJxZP9MqUi5iid2dw4Jg/HvtDpCcLj1GLIhCDaebKegajCJlMhhxnDXrGFLJfX8j
# 7k7LUvrZDsQniJZ3D66K+3SZTLhvwK7dMGVFuUUJUfDifrlCTjKG9mxsPDllfyck
# 4zGnRZv8Jw9RgE1zAghnU14L0vVUNOzi/4bE7wIsiRyIcCcVoXRneBA3n/frLXvd
# jDsbb2lpGu78+s1zbO5N0bhHWq4j5WMutrspBxEhqG2PSBjC5Ypi+jhtfu3+x76N
# mBvsyKuxx9+Hm/ALnlzKxr4KyMR3/z4IRMzA1QyppNk65Ui+jB14g+w4vole33M1
# pVqVckrmSebUkmjnCshCiH12IFgHZF7gRwE4YZrJ7QjxZeoZqHaKsQLRMp653beB
# fHfeva9zJPhBSdVcCW7x9q0c2HVPLJHX9YCUU714I+qtLpDGrdbZxD9mikPqL/To
# /1lDZ0ch8FtePhME7houuoPcMIIHejCCBWKgAwIBAgIKYQ6Q0gAAAAAAAzANBgkq
# hkiG9w0BAQsFADCBiDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24x
# EDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlv
# bjEyMDAGA1UEAxMpTWljcm9zb2Z0IFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9yaXR5
# IDIwMTEwHhcNMTEwNzA4MjA1OTA5WhcNMjYwNzA4MjEwOTA5WjB+MQswCQYDVQQG
# EwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwG
# A1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMSgwJgYDVQQDEx9NaWNyb3NvZnQg
# Q29kZSBTaWduaW5nIFBDQSAyMDExMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIIC
# CgKCAgEAq/D6chAcLq3YbqqCEE00uvK2WCGfQhsqa+laUKq4BjgaBEm6f8MMHt03
# a8YS2AvwOMKZBrDIOdUBFDFC04kNeWSHfpRgJGyvnkmc6Whe0t+bU7IKLMOv2akr
# rnoJr9eWWcpgGgXpZnboMlImEi/nqwhQz7NEt13YxC4Ddato88tt8zpcoRb0Rrrg
# OGSsbmQ1eKagYw8t00CT+OPeBw3VXHmlSSnnDb6gE3e+lD3v++MrWhAfTVYoonpy
# 4BI6t0le2O3tQ5GD2Xuye4Yb2T6xjF3oiU+EGvKhL1nkkDstrjNYxbc+/jLTswM9
# sbKvkjh+0p2ALPVOVpEhNSXDOW5kf1O6nA+tGSOEy/S6A4aN91/w0FK/jJSHvMAh
# dCVfGCi2zCcoOCWYOUo2z3yxkq4cI6epZuxhH2rhKEmdX4jiJV3TIUs+UsS1Vz8k
# A/DRelsv1SPjcF0PUUZ3s/gA4bysAoJf28AVs70b1FVL5zmhD+kjSbwYuER8ReTB
# w3J64HLnJN+/RpnF78IcV9uDjexNSTCnq47f7Fufr/zdsGbiwZeBe+3W7UvnSSmn
# Eyimp31ngOaKYnhfsi+E11ecXL93KCjx7W3DKI8sj0A3T8HhhUSJxAlMxdSlQy90
# lfdu+HggWCwTXWCVmj5PM4TasIgX3p5O9JawvEagbJjS4NaIjAsCAwEAAaOCAe0w
# ggHpMBAGCSsGAQQBgjcVAQQDAgEAMB0GA1UdDgQWBBRIbmTlUAXTgqoXNzcitW2o
# ynUClTAZBgkrBgEEAYI3FAIEDB4KAFMAdQBiAEMAQTALBgNVHQ8EBAMCAYYwDwYD
# VR0TAQH/BAUwAwEB/zAfBgNVHSMEGDAWgBRyLToCMZBDuRQFTuHqp8cx0SOJNDBa
# BgNVHR8EUzBRME+gTaBLhklodHRwOi8vY3JsLm1pY3Jvc29mdC5jb20vcGtpL2Ny
# bC9wcm9kdWN0cy9NaWNSb29DZXJBdXQyMDExXzIwMTFfMDNfMjIuY3JsMF4GCCsG
# AQUFBwEBBFIwUDBOBggrBgEFBQcwAoZCaHR0cDovL3d3dy5taWNyb3NvZnQuY29t
# L3BraS9jZXJ0cy9NaWNSb29DZXJBdXQyMDExXzIwMTFfMDNfMjIuY3J0MIGfBgNV
# HSAEgZcwgZQwgZEGCSsGAQQBgjcuAzCBgzA/BggrBgEFBQcCARYzaHR0cDovL3d3
# dy5taWNyb3NvZnQuY29tL3BraW9wcy9kb2NzL3ByaW1hcnljcHMuaHRtMEAGCCsG
# AQUFBwICMDQeMiAdAEwAZQBnAGEAbABfAHAAbwBsAGkAYwB5AF8AcwB0AGEAdABl
# AG0AZQBuAHQALiAdMA0GCSqGSIb3DQEBCwUAA4ICAQBn8oalmOBUeRou09h0ZyKb
# C5YR4WOSmUKWfdJ5DJDBZV8uLD74w3LRbYP+vj/oCso7v0epo/Np22O/IjWll11l
# hJB9i0ZQVdgMknzSGksc8zxCi1LQsP1r4z4HLimb5j0bpdS1HXeUOeLpZMlEPXh6
# I/MTfaaQdION9MsmAkYqwooQu6SpBQyb7Wj6aC6VoCo/KmtYSWMfCWluWpiW5IP0
# wI/zRive/DvQvTXvbiWu5a8n7dDd8w6vmSiXmE0OPQvyCInWH8MyGOLwxS3OW560
# STkKxgrCxq2u5bLZ2xWIUUVYODJxJxp/sfQn+N4sOiBpmLJZiWhub6e3dMNABQam
# ASooPoI/E01mC8CzTfXhj38cbxV9Rad25UAqZaPDXVJihsMdYzaXht/a8/jyFqGa
# J+HNpZfQ7l1jQeNbB5yHPgZ3BtEGsXUfFL5hYbXw3MYbBL7fQccOKO7eZS/sl/ah
# XJbYANahRr1Z85elCUtIEJmAH9AAKcWxm6U/RXceNcbSoqKfenoi+kiVH6v7RyOA
# 9Z74v2u3S5fi63V4GuzqN5l5GEv/1rMjaHXmr/r8i+sLgOppO6/8MO0ETI7f33Vt
# Y5E90Z1WTk+/gFcioXgRMiF670EKsT/7qMykXcGhiJtXcVZOSEXAQsmbdlsKgEhr
# /Xmfwb1tbWrJUnMTDXpQzTGCGbkwghm1AgEBMIGVMH4xCzAJBgNVBAYTAlVTMRMw
# EQYDVQQIEwpXYXNoaW5ndG9uMRAwDgYDVQQHEwdSZWRtb25kMR4wHAYDVQQKExVN
# aWNyb3NvZnQgQ29ycG9yYXRpb24xKDAmBgNVBAMTH01pY3Jvc29mdCBDb2RlIFNp
# Z25pbmcgUENBIDIwMTECEzMAAALLt3U5+wJxQjYAAAAAAsswDQYJYIZIAWUDBAIB
# BQCggcYwGQYJKoZIhvcNAQkDMQwGCisGAQQBgjcCAQQwHAYKKwYBBAGCNwIBCzEO
# MAwGCisGAQQBgjcCARUwLwYJKoZIhvcNAQkEMSIEIBnKLfa83PrOs1tdX3fMcwrL
# NvGMlkCK3T7vqq4tGcyLMFoGCisGAQQBgjcCAQwxTDBKoBqAGABDAFMAUwAgAEUA
# eABjAGgAYQBuAGcAZaEsgCpodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L0NT
# Uy1FeGNoYW5nZSAwDQYJKoZIhvcNAQEBBQAEggEAmdceGVAWxcKCxFyJNbHnSx+P
# 0nFyeVKfNA1oWiEcLqEhd8O5MU74sTM3mkAJFIQklL3we2Z+Wvb5GyQ9oSqRf7zT
# rZokU4sYE4nTA0mu4MMosNlc883BUmC7yCNpcOoTMOnxrVPT8Vk1rDM5LPKsNuNk
# rXK9Tl/9HfhfxexsJfQpI5ofrDNfW1Ohr8fl3lwPxd29z5GV/Iv0zq3baJBm9bgB
# DPZ00j17Y6Z4K1FXPE4wSerwQnKiopNWaF5qw11EdWWH/INBODVabz4Jz6hPryGi
# dhRfAiMNikvl1AMepwGvtJrAQQKNU8cBlng8uAyaCudHkNSPQo5M3lQ8LEiENqGC
# FyswghcnBgorBgEEAYI3AwMBMYIXFzCCFxMGCSqGSIb3DQEHAqCCFwQwghcAAgED
# MQ8wDQYJYIZIAWUDBAIBBQAwggFZBgsqhkiG9w0BCRABBKCCAUgEggFEMIIBQAIB
# AQYKKwYBBAGEWQoDATAxMA0GCWCGSAFlAwQCAQUABCC9NyfMwJaW5WDIITve0qWh
# GBi2teiDhtMxne1txHhGnAIGZBsROnW4GBMyMDIzMDMyMjIyMjc1NC44MDlaMASA
# AgH0oIHYpIHVMIHSMQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQ
# MA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9u
# MS0wKwYDVQQLEyRNaWNyb3NvZnQgSXJlbGFuZCBPcGVyYXRpb25zIExpbWl0ZWQx
# JjAkBgNVBAsTHVRoYWxlcyBUU1MgRVNOOjE3OUUtNEJCMC04MjQ2MSUwIwYDVQQD
# ExxNaWNyb3NvZnQgVGltZS1TdGFtcCBTZXJ2aWNloIIRejCCBycwggUPoAMCAQIC
# EzMAAAG1rRrf14VwbRMAAQAAAbUwDQYJKoZIhvcNAQELBQAwfDELMAkGA1UEBhMC
# VVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNV
# BAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEmMCQGA1UEAxMdTWljcm9zb2Z0IFRp
# bWUtU3RhbXAgUENBIDIwMTAwHhcNMjIwOTIwMjAyMjExWhcNMjMxMjE0MjAyMjEx
# WjCB0jELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcT
# B1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEtMCsGA1UE
# CxMkTWljcm9zb2Z0IElyZWxhbmQgT3BlcmF0aW9ucyBMaW1pdGVkMSYwJAYDVQQL
# Ex1UaGFsZXMgVFNTIEVTTjoxNzlFLTRCQjAtODI0NjElMCMGA1UEAxMcTWljcm9z
# b2Z0IFRpbWUtU3RhbXAgU2VydmljZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCC
# AgoCggIBAJcLCrhlXoLCjYmFxcFPgkh57dmuz31sNsj8IlvmEZRCbB94mxSIj35P
# 8m5TKfCRmp7bvuw4v/t3ucFjf52yVCDFIxFiZ3PCTI6D5hwlrDLSTrkf9UbuGmtU
# a8ULSHpatPfEwZeJOzbBBPO5e6ihZsvIsBjUI5MK9GzLuAScMuwVF4lx3oDklPfd
# q30OMTWaMc57+Nky0LHPTZnAauVrJZKlQE3HPD0n4ASxKXRtQ6dsKjcOCayRcCTQ
# NW3800nGAAXObJkWQYLD+CYiv/Ala5aHIXhMkKJ45t6xbba6IwK3klJ4sQC7vaQ6
# 7ASOA1Dxht+KCG4niNaKhZf8ZOwPu7jPJOKPInzFVjU2nM2z5XQ2LZ+oQa3u69uU
# RA+LnnAsT/A8ct+GD1BJVpZTz9ywF6eXDMEY8fhFs4xLSCxCl7gHH8a1wk8MmIZu
# VzcwgmWIeP4BdlNsv22H3pCqWqBWMJKGXk+mcaEG1+Sn7YI/rWZBVdtVL2SJCem9
# +Gv+OHba7CunYk5lZzUzPSej+hIZZNrH3FMGxyBi/JmKnSjosneEcTgpkr3BTZGR
# IK5OePJhwmw208jvcUszdRJFsW6fJ/yx1Z2fX6eYSCxp7ZDM2g+Wl0QkMh0iIbD7
# Ue0P6yqB8oxaoLRjvX7Z8WL8cza2ynjAs8JnKsDK1+h3MXtEnimfAgMBAAGjggFJ
# MIIBRTAdBgNVHQ4EFgQUbFCG2YKGVV1V1VkF9DpNVTtmx1MwHwYDVR0jBBgwFoAU
# n6cVXQBeYl2D9OXSZacbUzUZ6XIwXwYDVR0fBFgwVjBUoFKgUIZOaHR0cDovL3d3
# dy5taWNyb3NvZnQuY29tL3BraW9wcy9jcmwvTWljcm9zb2Z0JTIwVGltZS1TdGFt
# cCUyMFBDQSUyMDIwMTAoMSkuY3JsMGwGCCsGAQUFBwEBBGAwXjBcBggrBgEFBQcw
# AoZQaHR0cDovL3d3dy5taWNyb3NvZnQuY29tL3BraW9wcy9jZXJ0cy9NaWNyb3Nv
# ZnQlMjBUaW1lLVN0YW1wJTIwUENBJTIwMjAxMCgxKS5jcnQwDAYDVR0TAQH/BAIw
# ADAWBgNVHSUBAf8EDDAKBggrBgEFBQcDCDAOBgNVHQ8BAf8EBAMCB4AwDQYJKoZI
# hvcNAQELBQADggIBAJBRjqcoyldrNrAPsE6g8A3YadJhaz7YlOKzdzqJ01qm/OTO
# lh9fXPz+de8boywoofx5ZT+cSlpl5wCEVdfzUA5CQS0nS02/zULXE9RVhkOwjE56
# 5/bS2caiBbSlcpb0Dcod9Qv6pAvEJjacs2pDtBt/LjhoDpCfRKuJwPu0MFX6Gw5Y
# IFrhKc3RZ0Xcly99oDqkr6y4xSqb+ChFamgU4msQlmQ5SIRt2IFM2u3JxuWdkgP3
# 3jKvyIldOgM1GnWcOl4HE66l5hJhNLTJnZeODDBQt8BlPQFXhQlinQ/Vjp2ANsx4
# Plxdi0FbaNFWLRS3enOg0BXJgd/BrzwilWEp/K9dBKF7kTfoEO4S3IptdnrDp1uB
# eGxwph1k1VngBoD4kiLRx0XxiixFGZqLVTnRT0fMIrgA0/3x0lwZJHaS9drb4BBh
# C3k858xbpWdem/zb+nbW4EkWa3nrCQTSqU43WI7vxqp5QJKX5S+idMMZPee/1FWJ
# 5o40WOtY1/dEBkJgc5vb7P/tm49Nl8f2118vL6ue45jV0NrnzmiZt5wHA9qjmksl
# xDo/ZqoTLeLXbzIx4YjT5XX49EOyqtR4HUQaylpMwkDYuLbPB0SQYqTWlaVn1OwX
# EZ/AXmM3S6CM8ESw7Wrc+mgYaN6A/21x62WoMaazOTLDAf61X2+V59WEu/7hMIIH
# cTCCBVmgAwIBAgITMwAAABXF52ueAptJmQAAAAAAFTANBgkqhkiG9w0BAQsFADCB
# iDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcTB1Jl
# ZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEyMDAGA1UEAxMp
# TWljcm9zb2Z0IFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9yaXR5IDIwMTAwHhcNMjEw
# OTMwMTgyMjI1WhcNMzAwOTMwMTgzMjI1WjB8MQswCQYDVQQGEwJVUzETMBEGA1UE
# CBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWljcm9z
# b2Z0IENvcnBvcmF0aW9uMSYwJAYDVQQDEx1NaWNyb3NvZnQgVGltZS1TdGFtcCBQ
# Q0EgMjAxMDCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAOThpkzntHIh
# C3miy9ckeb0O1YLT/e6cBwfSqWxOdcjKNVf2AX9sSuDivbk+F2Az/1xPx2b3lVNx
# WuJ+Slr+uDZnhUYjDLWNE893MsAQGOhgfWpSg0S3po5GawcU88V29YZQ3MFEyHFc
# UTE3oAo4bo3t1w/YJlN8OWECesSq/XJprx2rrPY2vjUmZNqYO7oaezOtgFt+jBAc
# nVL+tuhiJdxqD89d9P6OU8/W7IVWTe/dvI2k45GPsjksUZzpcGkNyjYtcI4xyDUo
# veO0hyTD4MmPfrVUj9z6BVWYbWg7mka97aSueik3rMvrg0XnRm7KMtXAhjBcTyzi
# YrLNueKNiOSWrAFKu75xqRdbZ2De+JKRHh09/SDPc31BmkZ1zcRfNN0Sidb9pSB9
# fvzZnkXftnIv231fgLrbqn427DZM9ituqBJR6L8FA6PRc6ZNN3SUHDSCD/AQ8rdH
# GO2n6Jl8P0zbr17C89XYcz1DTsEzOUyOArxCaC4Q6oRRRuLRvWoYWmEBc8pnol7X
# KHYC4jMYctenIPDC+hIK12NvDMk2ZItboKaDIV1fMHSRlJTYuVD5C4lh8zYGNRiE
# R9vcG9H9stQcxWv2XFJRXRLbJbqvUAV6bMURHXLvjflSxIUXk8A8FdsaN8cIFRg/
# eKtFtvUeh17aj54WcmnGrnu3tz5q4i6tAgMBAAGjggHdMIIB2TASBgkrBgEEAYI3
# FQEEBQIDAQABMCMGCSsGAQQBgjcVAgQWBBQqp1L+ZMSavoKRPEY1Kc8Q/y8E7jAd
# BgNVHQ4EFgQUn6cVXQBeYl2D9OXSZacbUzUZ6XIwXAYDVR0gBFUwUzBRBgwrBgEE
# AYI3TIN9AQEwQTA/BggrBgEFBQcCARYzaHR0cDovL3d3dy5taWNyb3NvZnQuY29t
# L3BraW9wcy9Eb2NzL1JlcG9zaXRvcnkuaHRtMBMGA1UdJQQMMAoGCCsGAQUFBwMI
# MBkGCSsGAQQBgjcUAgQMHgoAUwB1AGIAQwBBMAsGA1UdDwQEAwIBhjAPBgNVHRMB
# Af8EBTADAQH/MB8GA1UdIwQYMBaAFNX2VsuP6KJcYmjRPZSQW9fOmhjEMFYGA1Ud
# HwRPME0wS6BJoEeGRWh0dHA6Ly9jcmwubWljcm9zb2Z0LmNvbS9wa2kvY3JsL3By
# b2R1Y3RzL01pY1Jvb0NlckF1dF8yMDEwLTA2LTIzLmNybDBaBggrBgEFBQcBAQRO
# MEwwSgYIKwYBBQUHMAKGPmh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9wa2kvY2Vy
# dHMvTWljUm9vQ2VyQXV0XzIwMTAtMDYtMjMuY3J0MA0GCSqGSIb3DQEBCwUAA4IC
# AQCdVX38Kq3hLB9nATEkW+Geckv8qW/qXBS2Pk5HZHixBpOXPTEztTnXwnE2P9pk
# bHzQdTltuw8x5MKP+2zRoZQYIu7pZmc6U03dmLq2HnjYNi6cqYJWAAOwBb6J6Gng
# ugnue99qb74py27YP0h1AdkY3m2CDPVtI1TkeFN1JFe53Z/zjj3G82jfZfakVqr3
# lbYoVSfQJL1AoL8ZthISEV09J+BAljis9/kpicO8F7BUhUKz/AyeixmJ5/ALaoHC
# gRlCGVJ1ijbCHcNhcy4sa3tuPywJeBTpkbKpW99Jo3QMvOyRgNI95ko+ZjtPu4b6
# MhrZlvSP9pEB9s7GdP32THJvEKt1MMU0sHrYUP4KWN1APMdUbZ1jdEgssU5HLcEU
# BHG/ZPkkvnNtyo4JvbMBV0lUZNlz138eW0QBjloZkWsNn6Qo3GcZKCS6OEuabvsh
# VGtqRRFHqfG3rsjoiV5PndLQTHa1V1QJsWkBRH58oWFsc/4Ku+xBZj1p/cvBQUl+
# fpO+y/g75LcVv7TOPqUxUYS8vwLBgqJ7Fx0ViY1w/ue10CgaiQuPNtq6TPmb/wrp
# NPgkNWcr4A245oyZ1uEi6vAnQj0llOZ0dFtq0Z4+7X6gMTN9vMvpe784cETRkPHI
# qzqKOghif9lwY1NNje6CbaUFEMFxBmoQtB1VM1izoXBm8qGCAtYwggI/AgEBMIIB
# AKGB2KSB1TCB0jELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAO
# BgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEt
# MCsGA1UECxMkTWljcm9zb2Z0IElyZWxhbmQgT3BlcmF0aW9ucyBMaW1pdGVkMSYw
# JAYDVQQLEx1UaGFsZXMgVFNTIEVTTjoxNzlFLTRCQjAtODI0NjElMCMGA1UEAxMc
# TWljcm9zb2Z0IFRpbWUtU3RhbXAgU2VydmljZaIjCgEBMAcGBSsOAwIaAxUAjTCf
# a9dUWY9D1rt7pPmkBxdyLFWggYMwgYCkfjB8MQswCQYDVQQGEwJVUzETMBEGA1UE
# CBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWljcm9z
# b2Z0IENvcnBvcmF0aW9uMSYwJAYDVQQDEx1NaWNyb3NvZnQgVGltZS1TdGFtcCBQ
# Q0EgMjAxMDANBgkqhkiG9w0BAQUFAAIFAOfFj7IwIhgPMjAyMzAzMjIyMjMxMTRa
# GA8yMDIzMDMyMzIyMzExNFowdjA8BgorBgEEAYRZCgQBMS4wLDAKAgUA58WPsgIB
# ADAJAgEAAgEEAgH/MAcCAQACAhFEMAoCBQDnxuEyAgEAMDYGCisGAQQBhFkKBAIx
# KDAmMAwGCisGAQQBhFkKAwKgCjAIAgEAAgMHoSChCjAIAgEAAgMBhqAwDQYJKoZI
# hvcNAQEFBQADgYEAOgnQkci45DWXzVc8YOPdkIZh3q4EhNUd1scamULV/U91KH6J
# z8YcwlfW4cCuvNrq7AKT7a2NelL4PoBxqdXpnDqq4Vixcs19xI4E/xcE6EaqNtFQ
# T5yU7ZHnftpNalTgl04ZTQ+BJsGXw+7U6mnMQOmv+WXmcfbm9dNhcbHqFa0xggQN
# MIIECQIBATCBkzB8MQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQ
# MA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9u
# MSYwJAYDVQQDEx1NaWNyb3NvZnQgVGltZS1TdGFtcCBQQ0EgMjAxMAITMwAAAbWt
# Gt/XhXBtEwABAAABtTANBglghkgBZQMEAgEFAKCCAUowGgYJKoZIhvcNAQkDMQ0G
# CyqGSIb3DQEJEAEEMC8GCSqGSIb3DQEJBDEiBCBXrlqspbHfsMO94gj2brp6lDUW
# /Fjw85sxDHTMvaG9yzCB+gYLKoZIhvcNAQkQAi8xgeowgecwgeQwgb0EICfKDTUt
# aGcWifYc3OVnIpp7Ykn0S8JclVzrlAgF8ciDMIGYMIGApH4wfDELMAkGA1UEBhMC
# VVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNV
# BAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEmMCQGA1UEAxMdTWljcm9zb2Z0IFRp
# bWUtU3RhbXAgUENBIDIwMTACEzMAAAG1rRrf14VwbRMAAQAAAbUwIgQgdmqXkHpt
# Fbex/Aandb+O5Lg3xOJ1uRxaWuiH43gsMLowDQYJKoZIhvcNAQELBQAEggIARepB
# 7ggafvOFtdzQIbgdBovEn2AWRMk92mX3SfXQ8z2EfOYf3Nf9Gt04nDP0EwaF2sqW
# dEZ/V1NJ1fizlq18I7i+qU4KqobuB5Ny0OLaAfB7nb80n0t0ikMd62PpBpUpifj5
# Zf+7VUnkwi++7zM4bB/1I+VpAmms/Pa4s8dzOTcn1Llynaa5rtu2J6xeEWFCAy+s
# MRlLIl0MaZjm/HjPuYZalcDw9rLyXDAkI+gPVRZN2dkVa1uPBMqK/LbuKJgh/aa7
# 3A60p+ey58BM83uHOpTKUfFicE/a8Gmk4kB0A2t+oZtTk683lhOTdWeBRODgc9Zh
# OMIPYZSco1qEcsSzlVq9/P2L/zkw5PtLPz3NHmzAuKGYpIqU9rx2+9l2q+pm5bIC
# C7r9uvyawPpbT/2CgEGTTCp6ZXIlw1Evatf1X5LpKHVo5mmO8jbKf9SG/A5rOQye
# gl3PWG8hX+D9FewrefEVgkrkngkIHmt4oaJO/1HHoyJSRRJ9Qf/7+7pOOJ/Wr8Oy
# jekclicp6FBzOWnJp8E+ZFt5C7rHkbhDVEGY0ke+0Pqb9yhx3kJWbcrbSXNuROcX
# YnAtVWDYhwX3yuUwszU5oB3jfJJiviDgJnzF24GaCdj3pjwLc7vJWNK8UZkpAsyF
# f4FHh6UVx8OU4OLq6O6AO8l8UUk1CYuHSjjtR7g=
# SIG # End signature block
